Created by PLY version 3.10 (http://www.dabeaz.com/ply)

Grammar

Rule 0     S' -> program
Rule 1     program -> joinspec sequentialspec
Rule 2     joinspec -> JOIN LPAREN arglist SEPARE arglist RPAREN RETURNS LPAREN identlist RPAREN LOCALS LPAREN arglist RPAREN block
Rule 3     joinspec -> JOIN error RPAREN block
Rule 4     joinspec -> JOIN LPAREN arglist SEPARE arglist RPAREN RETURNS LPAREN identlist RPAREN LOCALS LPAREN arglist RPAREN error
Rule 5     sequentialspec -> SEQUENTIAL LPAREN arglist RPAREN RETURNS LPAREN identlist RPAREN LOCALS LPAREN arglist RPAREN block
Rule 6     arglist -> arglist COMMA arg
Rule 7     arglist -> arg
Rule 8     arglist -> <empty>
Rule 9     arg -> type IDENT
Rule 10    arg -> error
Rule 11    identlist -> identifier
Rule 12    identlist -> identifier COMMA identlist
Rule 13    identlist -> <empty>
Rule 14    constant -> NUMBER
Rule 15    constant -> TRUE
Rule 16    constant -> FALSE
Rule 17    postfixExpression -> constant
Rule 18    postfixExpression -> identifier
Rule 19    postfixExpression -> LPAREN expression RPAREN
Rule 20    identifier -> IDENT
Rule 21    postfixExpression -> postfixExpression LBRACKET expression RBRACKET
Rule 22    postfixExpression -> IDENT LPAREN expressionlist RPAREN
Rule 23    unaryExpression -> unop unaryExpression
Rule 24    unaryExpression -> postfixExpression
Rule 25    unop -> PLUS
Rule 26    unop -> MINUS
Rule 27    unop -> EXCLAMATION
Rule 28    unop -> TILDE
Rule 29    multiplicativeExpression -> unaryExpression
Rule 30    multiplicativeExpression -> multiplicativeExpression multop unaryExpression
Rule 31    multop -> TIMES
Rule 32    multop -> DIV
Rule 33    additiveExpression -> multiplicativeExpression
Rule 34    additiveExpression -> additiveExpression addop multiplicativeExpression
Rule 35    addop -> PLUS
Rule 36    addop -> MINUS
Rule 37    relationalExpression -> additiveExpression
Rule 38    relationalExpression -> relationalExpression compop additiveExpression
Rule 39    compop -> LT
Rule 40    compop -> LEQ
Rule 41    compop -> GT
Rule 42    compop -> GEQ
Rule 43    equalityExpression -> relationalExpression
Rule 44    equalityExpression -> equalityExpression eqop relationalExpression
Rule 45    eqop -> EQEQ
Rule 46    eqop -> NEQ
Rule 47    andExpression -> equalityExpression
Rule 48    andExpression -> andExpression AND equalityExpression
Rule 49    orExpression -> andExpression
Rule 50    orExpression -> orExpression OR andExpression
Rule 51    conditionalExpression -> orExpression
Rule 52    conditionalExpression -> orExpression QUESTION expression COLON expression
Rule 53    expression -> conditionalExpression
Rule 54    expressionlist -> expression
Rule 55    expressionlist -> expressionlist COMMA expression
Rule 56    expressionlist -> <empty>
Rule 57    statementlist -> statementlist statement
Rule 58    statementlist -> <empty>
Rule 59    assignmentStatement -> postfixExpression EQ expression
Rule 60    assignmentStatement -> IDENT PLUS PLUS
Rule 61    assignmentStatement -> IDENT MINUS MINUS
Rule 62    assignmentStatement -> postfixExpression EQ error
Rule 63    assignmentStatement -> error EQ expression
Rule 64    statement -> assignmentStatement SEMICOLON
Rule 65    statement -> iterationStatement
Rule 66    statement -> selectionStatement
Rule 67    statement -> block
Rule 68    statement -> error SEMICOLON
Rule 69    selectionStatement -> IF LPAREN expression RPAREN statement ELSE statement
Rule 70    selectionStatement -> IF LPAREN expression RPAREN statement
Rule 71    iterationStatement -> FOR LPAREN assignmentStatement SEMICOLON expression SEMICOLON assignmentStatement RPAREN statement
Rule 72    block -> LBRACE statementlist RBRACE
Rule 73    type -> INT
Rule 74    type -> FLOAT
Rule 75    type -> BOOL
Rule 76    type -> type TIMES

Terminals, with rules where they appear

AND                  : 48
BOOL                 : 75
COLON                : 52
COMMA                : 6 12 55
DIV                  : 32
ELSE                 : 69
EQ                   : 59 62 63
EQEQ                 : 45
EXCLAMATION          : 27
FALSE                : 16
FLOAT                : 74
FOR                  : 71
GEQ                  : 42
GT                   : 41
IDENT                : 9 20 22 60 61
IF                   : 69 70
INT                  : 73
JOIN                 : 2 3 4
LBRACE               : 72
LBRACKET             : 21
LEQ                  : 40
LOCALS               : 2 4 5
LPAREN               : 2 2 2 4 4 4 5 5 5 19 22 69 70 71
LT                   : 39
MINUS                : 26 36 61 61
NEQ                  : 46
NUMBER               : 14
OR                   : 50
PLUS                 : 25 35 60 60
QUESTION             : 52
RBRACE               : 72
RBRACKET             : 21
RETURNS              : 2 4 5
RPAREN               : 2 2 2 3 4 4 4 5 5 5 19 22 69 70 71
SEMICOLON            : 64 68 71 71
SEPARE               : 2 4
SEQUENTIAL           : 5
TILDE                : 28
TIMES                : 31 76
TRUE                 : 15
error                : 3 4 10 62 63 68

Nonterminals, with rules where they appear

additiveExpression   : 34 37 38
addop                : 34
andExpression        : 48 49 50
arg                  : 6 7
arglist              : 2 2 2 4 4 4 5 5 6
assignmentStatement  : 64 71 71
block                : 2 3 5 67
compop               : 38
conditionalExpression : 53
constant             : 17
eqop                 : 44
equalityExpression   : 44 47 48
expression           : 19 21 52 52 54 55 59 63 69 70 71
expressionlist       : 22 55
identifier           : 11 12 18
identlist            : 2 4 5 12
iterationStatement   : 65
joinspec             : 1
multiplicativeExpression : 30 33 34
multop               : 30
orExpression         : 50 51 52
postfixExpression    : 21 24 59 62
program              : 0
relationalExpression : 38 43 44
selectionStatement   : 66
sequentialspec       : 1
statement            : 57 69 69 70 71
statementlist        : 57 72
type                 : 9 76
unaryExpression      : 23 29 30
unop                 : 23

Parsing method: LALR

state 0

    (0) S' -> . program
    (1) program -> . joinspec sequentialspec
    (2) joinspec -> . JOIN LPAREN arglist SEPARE arglist RPAREN RETURNS LPAREN identlist RPAREN LOCALS LPAREN arglist RPAREN block
    (3) joinspec -> . JOIN error RPAREN block
    (4) joinspec -> . JOIN LPAREN arglist SEPARE arglist RPAREN RETURNS LPAREN identlist RPAREN LOCALS LPAREN arglist RPAREN error

    JOIN            shift and go to state 1

    joinspec                       shift and go to state 2
    program                        shift and go to state 3

state 1

    (2) joinspec -> JOIN . LPAREN arglist SEPARE arglist RPAREN RETURNS LPAREN identlist RPAREN LOCALS LPAREN arglist RPAREN block
    (3) joinspec -> JOIN . error RPAREN block
    (4) joinspec -> JOIN . LPAREN arglist SEPARE arglist RPAREN RETURNS LPAREN identlist RPAREN LOCALS LPAREN arglist RPAREN error

    LPAREN          shift and go to state 4
    error           shift and go to state 5


state 2

    (1) program -> joinspec . sequentialspec
    (5) sequentialspec -> . SEQUENTIAL LPAREN arglist RPAREN RETURNS LPAREN identlist RPAREN LOCALS LPAREN arglist RPAREN block

    SEQUENTIAL      shift and go to state 7

    sequentialspec                 shift and go to state 6

state 3

    (0) S' -> program .



state 4

    (2) joinspec -> JOIN LPAREN . arglist SEPARE arglist RPAREN RETURNS LPAREN identlist RPAREN LOCALS LPAREN arglist RPAREN block
    (4) joinspec -> JOIN LPAREN . arglist SEPARE arglist RPAREN RETURNS LPAREN identlist RPAREN LOCALS LPAREN arglist RPAREN error
    (6) arglist -> . arglist COMMA arg
    (7) arglist -> . arg
    (8) arglist -> .
    (9) arg -> . type IDENT
    (10) arg -> . error
    (73) type -> . INT
    (74) type -> . FLOAT
    (75) type -> . BOOL
    (76) type -> . type TIMES

    SEPARE          reduce using rule 8 (arglist -> .)
    COMMA           reduce using rule 8 (arglist -> .)
    error           shift and go to state 12
    INT             shift and go to state 8
    FLOAT           shift and go to state 11
    BOOL            shift and go to state 14

    arglist                        shift and go to state 13
    type                           shift and go to state 9
    arg                            shift and go to state 10

state 5

    (3) joinspec -> JOIN error . RPAREN block

    RPAREN          shift and go to state 15


state 6

    (1) program -> joinspec sequentialspec .

    $end            reduce using rule 1 (program -> joinspec sequentialspec .)


state 7

    (5) sequentialspec -> SEQUENTIAL . LPAREN arglist RPAREN RETURNS LPAREN identlist RPAREN LOCALS LPAREN arglist RPAREN block

    LPAREN          shift and go to state 16


state 8

    (73) type -> INT .

    IDENT           reduce using rule 73 (type -> INT .)
    TIMES           reduce using rule 73 (type -> INT .)


state 9

    (9) arg -> type . IDENT
    (76) type -> type . TIMES

    IDENT           shift and go to state 17
    TIMES           shift and go to state 18


state 10

    (7) arglist -> arg .

    SEPARE          reduce using rule 7 (arglist -> arg .)
    COMMA           reduce using rule 7 (arglist -> arg .)
    RPAREN          reduce using rule 7 (arglist -> arg .)


state 11

    (74) type -> FLOAT .

    IDENT           reduce using rule 74 (type -> FLOAT .)
    TIMES           reduce using rule 74 (type -> FLOAT .)


state 12

    (10) arg -> error .

    SEPARE          reduce using rule 10 (arg -> error .)
    COMMA           reduce using rule 10 (arg -> error .)
    RPAREN          reduce using rule 10 (arg -> error .)


state 13

    (2) joinspec -> JOIN LPAREN arglist . SEPARE arglist RPAREN RETURNS LPAREN identlist RPAREN LOCALS LPAREN arglist RPAREN block
    (4) joinspec -> JOIN LPAREN arglist . SEPARE arglist RPAREN RETURNS LPAREN identlist RPAREN LOCALS LPAREN arglist RPAREN error
    (6) arglist -> arglist . COMMA arg

    SEPARE          shift and go to state 20
    COMMA           shift and go to state 19


state 14

    (75) type -> BOOL .

    IDENT           reduce using rule 75 (type -> BOOL .)
    TIMES           reduce using rule 75 (type -> BOOL .)


state 15

    (3) joinspec -> JOIN error RPAREN . block
    (72) block -> . LBRACE statementlist RBRACE

    LBRACE          shift and go to state 21

    block                          shift and go to state 22

state 16

    (5) sequentialspec -> SEQUENTIAL LPAREN . arglist RPAREN RETURNS LPAREN identlist RPAREN LOCALS LPAREN arglist RPAREN block
    (6) arglist -> . arglist COMMA arg
    (7) arglist -> . arg
    (8) arglist -> .
    (9) arg -> . type IDENT
    (10) arg -> . error
    (73) type -> . INT
    (74) type -> . FLOAT
    (75) type -> . BOOL
    (76) type -> . type TIMES

    RPAREN          reduce using rule 8 (arglist -> .)
    COMMA           reduce using rule 8 (arglist -> .)
    error           shift and go to state 12
    INT             shift and go to state 8
    FLOAT           shift and go to state 11
    BOOL            shift and go to state 14

    arglist                        shift and go to state 23
    type                           shift and go to state 9
    arg                            shift and go to state 10

state 17

    (9) arg -> type IDENT .

    SEPARE          reduce using rule 9 (arg -> type IDENT .)
    COMMA           reduce using rule 9 (arg -> type IDENT .)
    RPAREN          reduce using rule 9 (arg -> type IDENT .)


state 18

    (76) type -> type TIMES .

    IDENT           reduce using rule 76 (type -> type TIMES .)
    TIMES           reduce using rule 76 (type -> type TIMES .)


state 19

    (6) arglist -> arglist COMMA . arg
    (9) arg -> . type IDENT
    (10) arg -> . error
    (73) type -> . INT
    (74) type -> . FLOAT
    (75) type -> . BOOL
    (76) type -> . type TIMES

    error           shift and go to state 12
    INT             shift and go to state 8
    FLOAT           shift and go to state 11
    BOOL            shift and go to state 14

    type                           shift and go to state 9
    arg                            shift and go to state 24

state 20

    (2) joinspec -> JOIN LPAREN arglist SEPARE . arglist RPAREN RETURNS LPAREN identlist RPAREN LOCALS LPAREN arglist RPAREN block
    (4) joinspec -> JOIN LPAREN arglist SEPARE . arglist RPAREN RETURNS LPAREN identlist RPAREN LOCALS LPAREN arglist RPAREN error
    (6) arglist -> . arglist COMMA arg
    (7) arglist -> . arg
    (8) arglist -> .
    (9) arg -> . type IDENT
    (10) arg -> . error
    (73) type -> . INT
    (74) type -> . FLOAT
    (75) type -> . BOOL
    (76) type -> . type TIMES

    RPAREN          reduce using rule 8 (arglist -> .)
    COMMA           reduce using rule 8 (arglist -> .)
    error           shift and go to state 12
    INT             shift and go to state 8
    FLOAT           shift and go to state 11
    BOOL            shift and go to state 14

    arglist                        shift and go to state 25
    type                           shift and go to state 9
    arg                            shift and go to state 10

state 21

    (72) block -> LBRACE . statementlist RBRACE
    (57) statementlist -> . statementlist statement
    (58) statementlist -> .

    RBRACE          reduce using rule 58 (statementlist -> .)
    error           reduce using rule 58 (statementlist -> .)
    IDENT           reduce using rule 58 (statementlist -> .)
    FOR             reduce using rule 58 (statementlist -> .)
    IF              reduce using rule 58 (statementlist -> .)
    LBRACE          reduce using rule 58 (statementlist -> .)
    LPAREN          reduce using rule 58 (statementlist -> .)
    NUMBER          reduce using rule 58 (statementlist -> .)
    TRUE            reduce using rule 58 (statementlist -> .)
    FALSE           reduce using rule 58 (statementlist -> .)

    statementlist                  shift and go to state 26

state 22

    (3) joinspec -> JOIN error RPAREN block .

    SEQUENTIAL      reduce using rule 3 (joinspec -> JOIN error RPAREN block .)


state 23

    (5) sequentialspec -> SEQUENTIAL LPAREN arglist . RPAREN RETURNS LPAREN identlist RPAREN LOCALS LPAREN arglist RPAREN block
    (6) arglist -> arglist . COMMA arg

    RPAREN          shift and go to state 27
    COMMA           shift and go to state 19


state 24

    (6) arglist -> arglist COMMA arg .

    SEPARE          reduce using rule 6 (arglist -> arglist COMMA arg .)
    COMMA           reduce using rule 6 (arglist -> arglist COMMA arg .)
    RPAREN          reduce using rule 6 (arglist -> arglist COMMA arg .)


state 25

    (2) joinspec -> JOIN LPAREN arglist SEPARE arglist . RPAREN RETURNS LPAREN identlist RPAREN LOCALS LPAREN arglist RPAREN block
    (4) joinspec -> JOIN LPAREN arglist SEPARE arglist . RPAREN RETURNS LPAREN identlist RPAREN LOCALS LPAREN arglist RPAREN error
    (6) arglist -> arglist . COMMA arg

    RPAREN          shift and go to state 28
    COMMA           shift and go to state 19


state 26

    (72) block -> LBRACE statementlist . RBRACE
    (57) statementlist -> statementlist . statement
    (64) statement -> . assignmentStatement SEMICOLON
    (65) statement -> . iterationStatement
    (66) statement -> . selectionStatement
    (67) statement -> . block
    (68) statement -> . error SEMICOLON
    (59) assignmentStatement -> . postfixExpression EQ expression
    (60) assignmentStatement -> . IDENT PLUS PLUS
    (61) assignmentStatement -> . IDENT MINUS MINUS
    (62) assignmentStatement -> . postfixExpression EQ error
    (63) assignmentStatement -> . error EQ expression
    (71) iterationStatement -> . FOR LPAREN assignmentStatement SEMICOLON expression SEMICOLON assignmentStatement RPAREN statement
    (69) selectionStatement -> . IF LPAREN expression RPAREN statement ELSE statement
    (70) selectionStatement -> . IF LPAREN expression RPAREN statement
    (72) block -> . LBRACE statementlist RBRACE
    (17) postfixExpression -> . constant
    (18) postfixExpression -> . identifier
    (19) postfixExpression -> . LPAREN expression RPAREN
    (21) postfixExpression -> . postfixExpression LBRACKET expression RBRACKET
    (22) postfixExpression -> . IDENT LPAREN expressionlist RPAREN
    (14) constant -> . NUMBER
    (15) constant -> . TRUE
    (16) constant -> . FALSE
    (20) identifier -> . IDENT

    RBRACE          shift and go to state 36
    error           shift and go to state 43
    IDENT           shift and go to state 35
    FOR             shift and go to state 37
    IF              shift and go to state 40
    LBRACE          shift and go to state 21
    LPAREN          shift and go to state 38
    NUMBER          shift and go to state 30
    TRUE            shift and go to state 31
    FALSE           shift and go to state 42

    postfixExpression              shift and go to state 41
    constant                       shift and go to state 29
    block                          shift and go to state 45
    statement                      shift and go to state 33
    identifier                     shift and go to state 44
    assignmentStatement            shift and go to state 34
    iterationStatement             shift and go to state 39
    selectionStatement             shift and go to state 32

state 27

    (5) sequentialspec -> SEQUENTIAL LPAREN arglist RPAREN . RETURNS LPAREN identlist RPAREN LOCALS LPAREN arglist RPAREN block

    RETURNS         shift and go to state 46


state 28

    (2) joinspec -> JOIN LPAREN arglist SEPARE arglist RPAREN . RETURNS LPAREN identlist RPAREN LOCALS LPAREN arglist RPAREN block
    (4) joinspec -> JOIN LPAREN arglist SEPARE arglist RPAREN . RETURNS LPAREN identlist RPAREN LOCALS LPAREN arglist RPAREN error

    RETURNS         shift and go to state 47


state 29

    (17) postfixExpression -> constant .

    LBRACKET        reduce using rule 17 (postfixExpression -> constant .)
    TIMES           reduce using rule 17 (postfixExpression -> constant .)
    DIV             reduce using rule 17 (postfixExpression -> constant .)
    PLUS            reduce using rule 17 (postfixExpression -> constant .)
    MINUS           reduce using rule 17 (postfixExpression -> constant .)
    LT              reduce using rule 17 (postfixExpression -> constant .)
    LEQ             reduce using rule 17 (postfixExpression -> constant .)
    GT              reduce using rule 17 (postfixExpression -> constant .)
    GEQ             reduce using rule 17 (postfixExpression -> constant .)
    EQEQ            reduce using rule 17 (postfixExpression -> constant .)
    NEQ             reduce using rule 17 (postfixExpression -> constant .)
    AND             reduce using rule 17 (postfixExpression -> constant .)
    QUESTION        reduce using rule 17 (postfixExpression -> constant .)
    OR              reduce using rule 17 (postfixExpression -> constant .)
    SEMICOLON       reduce using rule 17 (postfixExpression -> constant .)
    RPAREN          reduce using rule 17 (postfixExpression -> constant .)
    COMMA           reduce using rule 17 (postfixExpression -> constant .)
    RBRACKET        reduce using rule 17 (postfixExpression -> constant .)
    COLON           reduce using rule 17 (postfixExpression -> constant .)
    EQ              reduce using rule 17 (postfixExpression -> constant .)


state 30

    (14) constant -> NUMBER .

    LBRACKET        reduce using rule 14 (constant -> NUMBER .)
    TIMES           reduce using rule 14 (constant -> NUMBER .)
    DIV             reduce using rule 14 (constant -> NUMBER .)
    PLUS            reduce using rule 14 (constant -> NUMBER .)
    MINUS           reduce using rule 14 (constant -> NUMBER .)
    LT              reduce using rule 14 (constant -> NUMBER .)
    LEQ             reduce using rule 14 (constant -> NUMBER .)
    GT              reduce using rule 14 (constant -> NUMBER .)
    GEQ             reduce using rule 14 (constant -> NUMBER .)
    EQEQ            reduce using rule 14 (constant -> NUMBER .)
    NEQ             reduce using rule 14 (constant -> NUMBER .)
    AND             reduce using rule 14 (constant -> NUMBER .)
    QUESTION        reduce using rule 14 (constant -> NUMBER .)
    OR              reduce using rule 14 (constant -> NUMBER .)
    RPAREN          reduce using rule 14 (constant -> NUMBER .)
    COMMA           reduce using rule 14 (constant -> NUMBER .)
    SEMICOLON       reduce using rule 14 (constant -> NUMBER .)
    RBRACKET        reduce using rule 14 (constant -> NUMBER .)
    COLON           reduce using rule 14 (constant -> NUMBER .)
    EQ              reduce using rule 14 (constant -> NUMBER .)


state 31

    (15) constant -> TRUE .

    LBRACKET        reduce using rule 15 (constant -> TRUE .)
    TIMES           reduce using rule 15 (constant -> TRUE .)
    DIV             reduce using rule 15 (constant -> TRUE .)
    PLUS            reduce using rule 15 (constant -> TRUE .)
    MINUS           reduce using rule 15 (constant -> TRUE .)
    LT              reduce using rule 15 (constant -> TRUE .)
    LEQ             reduce using rule 15 (constant -> TRUE .)
    GT              reduce using rule 15 (constant -> TRUE .)
    GEQ             reduce using rule 15 (constant -> TRUE .)
    EQEQ            reduce using rule 15 (constant -> TRUE .)
    NEQ             reduce using rule 15 (constant -> TRUE .)
    AND             reduce using rule 15 (constant -> TRUE .)
    QUESTION        reduce using rule 15 (constant -> TRUE .)
    OR              reduce using rule 15 (constant -> TRUE .)
    RPAREN          reduce using rule 15 (constant -> TRUE .)
    COMMA           reduce using rule 15 (constant -> TRUE .)
    SEMICOLON       reduce using rule 15 (constant -> TRUE .)
    RBRACKET        reduce using rule 15 (constant -> TRUE .)
    COLON           reduce using rule 15 (constant -> TRUE .)
    EQ              reduce using rule 15 (constant -> TRUE .)


state 32

    (66) statement -> selectionStatement .

    ELSE            reduce using rule 66 (statement -> selectionStatement .)
    RBRACE          reduce using rule 66 (statement -> selectionStatement .)
    error           reduce using rule 66 (statement -> selectionStatement .)
    IDENT           reduce using rule 66 (statement -> selectionStatement .)
    FOR             reduce using rule 66 (statement -> selectionStatement .)
    IF              reduce using rule 66 (statement -> selectionStatement .)
    LBRACE          reduce using rule 66 (statement -> selectionStatement .)
    LPAREN          reduce using rule 66 (statement -> selectionStatement .)
    NUMBER          reduce using rule 66 (statement -> selectionStatement .)
    TRUE            reduce using rule 66 (statement -> selectionStatement .)
    FALSE           reduce using rule 66 (statement -> selectionStatement .)


state 33

    (57) statementlist -> statementlist statement .

    RBRACE          reduce using rule 57 (statementlist -> statementlist statement .)
    error           reduce using rule 57 (statementlist -> statementlist statement .)
    IDENT           reduce using rule 57 (statementlist -> statementlist statement .)
    FOR             reduce using rule 57 (statementlist -> statementlist statement .)
    IF              reduce using rule 57 (statementlist -> statementlist statement .)
    LBRACE          reduce using rule 57 (statementlist -> statementlist statement .)
    LPAREN          reduce using rule 57 (statementlist -> statementlist statement .)
    NUMBER          reduce using rule 57 (statementlist -> statementlist statement .)
    TRUE            reduce using rule 57 (statementlist -> statementlist statement .)
    FALSE           reduce using rule 57 (statementlist -> statementlist statement .)


state 34

    (64) statement -> assignmentStatement . SEMICOLON

    SEMICOLON       shift and go to state 48


state 35

    (60) assignmentStatement -> IDENT . PLUS PLUS
    (61) assignmentStatement -> IDENT . MINUS MINUS
    (22) postfixExpression -> IDENT . LPAREN expressionlist RPAREN
    (20) identifier -> IDENT .

    PLUS            shift and go to state 50
    MINUS           shift and go to state 51
    LPAREN          shift and go to state 49
    EQ              reduce using rule 20 (identifier -> IDENT .)
    LBRACKET        reduce using rule 20 (identifier -> IDENT .)


state 36

    (72) block -> LBRACE statementlist RBRACE .

    SEQUENTIAL      reduce using rule 72 (block -> LBRACE statementlist RBRACE .)
    $end            reduce using rule 72 (block -> LBRACE statementlist RBRACE .)
    ELSE            reduce using rule 72 (block -> LBRACE statementlist RBRACE .)
    RBRACE          reduce using rule 72 (block -> LBRACE statementlist RBRACE .)
    error           reduce using rule 72 (block -> LBRACE statementlist RBRACE .)
    IDENT           reduce using rule 72 (block -> LBRACE statementlist RBRACE .)
    FOR             reduce using rule 72 (block -> LBRACE statementlist RBRACE .)
    IF              reduce using rule 72 (block -> LBRACE statementlist RBRACE .)
    LBRACE          reduce using rule 72 (block -> LBRACE statementlist RBRACE .)
    LPAREN          reduce using rule 72 (block -> LBRACE statementlist RBRACE .)
    NUMBER          reduce using rule 72 (block -> LBRACE statementlist RBRACE .)
    TRUE            reduce using rule 72 (block -> LBRACE statementlist RBRACE .)
    FALSE           reduce using rule 72 (block -> LBRACE statementlist RBRACE .)


state 37

    (71) iterationStatement -> FOR . LPAREN assignmentStatement SEMICOLON expression SEMICOLON assignmentStatement RPAREN statement

    LPAREN          shift and go to state 52


state 38

    (19) postfixExpression -> LPAREN . expression RPAREN
    (53) expression -> . conditionalExpression
    (51) conditionalExpression -> . orExpression
    (52) conditionalExpression -> . orExpression QUESTION expression COLON expression
    (49) orExpression -> . andExpression
    (50) orExpression -> . orExpression OR andExpression
    (47) andExpression -> . equalityExpression
    (48) andExpression -> . andExpression AND equalityExpression
    (43) equalityExpression -> . relationalExpression
    (44) equalityExpression -> . equalityExpression eqop relationalExpression
    (37) relationalExpression -> . additiveExpression
    (38) relationalExpression -> . relationalExpression compop additiveExpression
    (33) additiveExpression -> . multiplicativeExpression
    (34) additiveExpression -> . additiveExpression addop multiplicativeExpression
    (29) multiplicativeExpression -> . unaryExpression
    (30) multiplicativeExpression -> . multiplicativeExpression multop unaryExpression
    (23) unaryExpression -> . unop unaryExpression
    (24) unaryExpression -> . postfixExpression
    (25) unop -> . PLUS
    (26) unop -> . MINUS
    (27) unop -> . EXCLAMATION
    (28) unop -> . TILDE
    (17) postfixExpression -> . constant
    (18) postfixExpression -> . identifier
    (19) postfixExpression -> . LPAREN expression RPAREN
    (21) postfixExpression -> . postfixExpression LBRACKET expression RBRACKET
    (22) postfixExpression -> . IDENT LPAREN expressionlist RPAREN
    (14) constant -> . NUMBER
    (15) constant -> . TRUE
    (16) constant -> . FALSE
    (20) identifier -> . IDENT

    PLUS            shift and go to state 59
    MINUS           shift and go to state 57
    EXCLAMATION     shift and go to state 64
    TILDE           shift and go to state 60
    LPAREN          shift and go to state 38
    IDENT           shift and go to state 56
    NUMBER          shift and go to state 30
    TRUE            shift and go to state 31
    FALSE           shift and go to state 42

    equalityExpression             shift and go to state 53
    additiveExpression             shift and go to state 61
    conditionalExpression          shift and go to state 62
    unaryExpression                shift and go to state 63
    multiplicativeExpression       shift and go to state 55
    orExpression                   shift and go to state 58
    relationalExpression           shift and go to state 65
    unop                           shift and go to state 54
    andExpression                  shift and go to state 66
    postfixExpression              shift and go to state 67
    constant                       shift and go to state 29
    identifier                     shift and go to state 44
    expression                     shift and go to state 68

state 39

    (65) statement -> iterationStatement .

    ELSE            reduce using rule 65 (statement -> iterationStatement .)
    RBRACE          reduce using rule 65 (statement -> iterationStatement .)
    error           reduce using rule 65 (statement -> iterationStatement .)
    IDENT           reduce using rule 65 (statement -> iterationStatement .)
    FOR             reduce using rule 65 (statement -> iterationStatement .)
    IF              reduce using rule 65 (statement -> iterationStatement .)
    LBRACE          reduce using rule 65 (statement -> iterationStatement .)
    LPAREN          reduce using rule 65 (statement -> iterationStatement .)
    NUMBER          reduce using rule 65 (statement -> iterationStatement .)
    TRUE            reduce using rule 65 (statement -> iterationStatement .)
    FALSE           reduce using rule 65 (statement -> iterationStatement .)


state 40

    (69) selectionStatement -> IF . LPAREN expression RPAREN statement ELSE statement
    (70) selectionStatement -> IF . LPAREN expression RPAREN statement

    LPAREN          shift and go to state 69


state 41

    (59) assignmentStatement -> postfixExpression . EQ expression
    (62) assignmentStatement -> postfixExpression . EQ error
    (21) postfixExpression -> postfixExpression . LBRACKET expression RBRACKET

    EQ              shift and go to state 70
    LBRACKET        shift and go to state 71


state 42

    (16) constant -> FALSE .

    LBRACKET        reduce using rule 16 (constant -> FALSE .)
    TIMES           reduce using rule 16 (constant -> FALSE .)
    DIV             reduce using rule 16 (constant -> FALSE .)
    PLUS            reduce using rule 16 (constant -> FALSE .)
    MINUS           reduce using rule 16 (constant -> FALSE .)
    LT              reduce using rule 16 (constant -> FALSE .)
    LEQ             reduce using rule 16 (constant -> FALSE .)
    GT              reduce using rule 16 (constant -> FALSE .)
    GEQ             reduce using rule 16 (constant -> FALSE .)
    EQEQ            reduce using rule 16 (constant -> FALSE .)
    NEQ             reduce using rule 16 (constant -> FALSE .)
    AND             reduce using rule 16 (constant -> FALSE .)
    QUESTION        reduce using rule 16 (constant -> FALSE .)
    OR              reduce using rule 16 (constant -> FALSE .)
    RPAREN          reduce using rule 16 (constant -> FALSE .)
    COMMA           reduce using rule 16 (constant -> FALSE .)
    SEMICOLON       reduce using rule 16 (constant -> FALSE .)
    RBRACKET        reduce using rule 16 (constant -> FALSE .)
    COLON           reduce using rule 16 (constant -> FALSE .)
    EQ              reduce using rule 16 (constant -> FALSE .)


state 43

    (68) statement -> error . SEMICOLON
    (63) assignmentStatement -> error . EQ expression

    SEMICOLON       shift and go to state 73
    EQ              shift and go to state 72


state 44

    (18) postfixExpression -> identifier .

    LBRACKET        reduce using rule 18 (postfixExpression -> identifier .)
    TIMES           reduce using rule 18 (postfixExpression -> identifier .)
    DIV             reduce using rule 18 (postfixExpression -> identifier .)
    PLUS            reduce using rule 18 (postfixExpression -> identifier .)
    MINUS           reduce using rule 18 (postfixExpression -> identifier .)
    LT              reduce using rule 18 (postfixExpression -> identifier .)
    LEQ             reduce using rule 18 (postfixExpression -> identifier .)
    GT              reduce using rule 18 (postfixExpression -> identifier .)
    GEQ             reduce using rule 18 (postfixExpression -> identifier .)
    EQEQ            reduce using rule 18 (postfixExpression -> identifier .)
    NEQ             reduce using rule 18 (postfixExpression -> identifier .)
    AND             reduce using rule 18 (postfixExpression -> identifier .)
    QUESTION        reduce using rule 18 (postfixExpression -> identifier .)
    OR              reduce using rule 18 (postfixExpression -> identifier .)
    SEMICOLON       reduce using rule 18 (postfixExpression -> identifier .)
    RPAREN          reduce using rule 18 (postfixExpression -> identifier .)
    COMMA           reduce using rule 18 (postfixExpression -> identifier .)
    RBRACKET        reduce using rule 18 (postfixExpression -> identifier .)
    COLON           reduce using rule 18 (postfixExpression -> identifier .)
    EQ              reduce using rule 18 (postfixExpression -> identifier .)


state 45

    (67) statement -> block .

    ELSE            reduce using rule 67 (statement -> block .)
    RBRACE          reduce using rule 67 (statement -> block .)
    error           reduce using rule 67 (statement -> block .)
    IDENT           reduce using rule 67 (statement -> block .)
    FOR             reduce using rule 67 (statement -> block .)
    IF              reduce using rule 67 (statement -> block .)
    LBRACE          reduce using rule 67 (statement -> block .)
    LPAREN          reduce using rule 67 (statement -> block .)
    NUMBER          reduce using rule 67 (statement -> block .)
    TRUE            reduce using rule 67 (statement -> block .)
    FALSE           reduce using rule 67 (statement -> block .)


state 46

    (5) sequentialspec -> SEQUENTIAL LPAREN arglist RPAREN RETURNS . LPAREN identlist RPAREN LOCALS LPAREN arglist RPAREN block

    LPAREN          shift and go to state 74


state 47

    (2) joinspec -> JOIN LPAREN arglist SEPARE arglist RPAREN RETURNS . LPAREN identlist RPAREN LOCALS LPAREN arglist RPAREN block
    (4) joinspec -> JOIN LPAREN arglist SEPARE arglist RPAREN RETURNS . LPAREN identlist RPAREN LOCALS LPAREN arglist RPAREN error

    LPAREN          shift and go to state 75


state 48

    (64) statement -> assignmentStatement SEMICOLON .

    ELSE            reduce using rule 64 (statement -> assignmentStatement SEMICOLON .)
    RBRACE          reduce using rule 64 (statement -> assignmentStatement SEMICOLON .)
    error           reduce using rule 64 (statement -> assignmentStatement SEMICOLON .)
    IDENT           reduce using rule 64 (statement -> assignmentStatement SEMICOLON .)
    FOR             reduce using rule 64 (statement -> assignmentStatement SEMICOLON .)
    IF              reduce using rule 64 (statement -> assignmentStatement SEMICOLON .)
    LBRACE          reduce using rule 64 (statement -> assignmentStatement SEMICOLON .)
    LPAREN          reduce using rule 64 (statement -> assignmentStatement SEMICOLON .)
    NUMBER          reduce using rule 64 (statement -> assignmentStatement SEMICOLON .)
    TRUE            reduce using rule 64 (statement -> assignmentStatement SEMICOLON .)
    FALSE           reduce using rule 64 (statement -> assignmentStatement SEMICOLON .)


state 49

    (22) postfixExpression -> IDENT LPAREN . expressionlist RPAREN
    (54) expressionlist -> . expression
    (55) expressionlist -> . expressionlist COMMA expression
    (56) expressionlist -> .
    (53) expression -> . conditionalExpression
    (51) conditionalExpression -> . orExpression
    (52) conditionalExpression -> . orExpression QUESTION expression COLON expression
    (49) orExpression -> . andExpression
    (50) orExpression -> . orExpression OR andExpression
    (47) andExpression -> . equalityExpression
    (48) andExpression -> . andExpression AND equalityExpression
    (43) equalityExpression -> . relationalExpression
    (44) equalityExpression -> . equalityExpression eqop relationalExpression
    (37) relationalExpression -> . additiveExpression
    (38) relationalExpression -> . relationalExpression compop additiveExpression
    (33) additiveExpression -> . multiplicativeExpression
    (34) additiveExpression -> . additiveExpression addop multiplicativeExpression
    (29) multiplicativeExpression -> . unaryExpression
    (30) multiplicativeExpression -> . multiplicativeExpression multop unaryExpression
    (23) unaryExpression -> . unop unaryExpression
    (24) unaryExpression -> . postfixExpression
    (25) unop -> . PLUS
    (26) unop -> . MINUS
    (27) unop -> . EXCLAMATION
    (28) unop -> . TILDE
    (17) postfixExpression -> . constant
    (18) postfixExpression -> . identifier
    (19) postfixExpression -> . LPAREN expression RPAREN
    (21) postfixExpression -> . postfixExpression LBRACKET expression RBRACKET
    (22) postfixExpression -> . IDENT LPAREN expressionlist RPAREN
    (14) constant -> . NUMBER
    (15) constant -> . TRUE
    (16) constant -> . FALSE
    (20) identifier -> . IDENT

    RPAREN          reduce using rule 56 (expressionlist -> .)
    COMMA           reduce using rule 56 (expressionlist -> .)
    PLUS            shift and go to state 59
    MINUS           shift and go to state 57
    EXCLAMATION     shift and go to state 64
    TILDE           shift and go to state 60
    LPAREN          shift and go to state 38
    IDENT           shift and go to state 56
    NUMBER          shift and go to state 30
    TRUE            shift and go to state 31
    FALSE           shift and go to state 42

    equalityExpression             shift and go to state 53
    additiveExpression             shift and go to state 61
    conditionalExpression          shift and go to state 62
    unaryExpression                shift and go to state 63
    multiplicativeExpression       shift and go to state 55
    orExpression                   shift and go to state 58
    relationalExpression           shift and go to state 65
    unop                           shift and go to state 54
    expressionlist                 shift and go to state 76
    andExpression                  shift and go to state 66
    postfixExpression              shift and go to state 67
    constant                       shift and go to state 29
    identifier                     shift and go to state 44
    expression                     shift and go to state 77

state 50

    (60) assignmentStatement -> IDENT PLUS . PLUS

    PLUS            shift and go to state 78


state 51

    (61) assignmentStatement -> IDENT MINUS . MINUS

    MINUS           shift and go to state 79


state 52

    (71) iterationStatement -> FOR LPAREN . assignmentStatement SEMICOLON expression SEMICOLON assignmentStatement RPAREN statement
    (59) assignmentStatement -> . postfixExpression EQ expression
    (60) assignmentStatement -> . IDENT PLUS PLUS
    (61) assignmentStatement -> . IDENT MINUS MINUS
    (62) assignmentStatement -> . postfixExpression EQ error
    (63) assignmentStatement -> . error EQ expression
    (17) postfixExpression -> . constant
    (18) postfixExpression -> . identifier
    (19) postfixExpression -> . LPAREN expression RPAREN
    (21) postfixExpression -> . postfixExpression LBRACKET expression RBRACKET
    (22) postfixExpression -> . IDENT LPAREN expressionlist RPAREN
    (14) constant -> . NUMBER
    (15) constant -> . TRUE
    (16) constant -> . FALSE
    (20) identifier -> . IDENT

    IDENT           shift and go to state 35
    error           shift and go to state 80
    LPAREN          shift and go to state 38
    NUMBER          shift and go to state 30
    TRUE            shift and go to state 31
    FALSE           shift and go to state 42

    postfixExpression              shift and go to state 41
    constant                       shift and go to state 29
    identifier                     shift and go to state 44
    assignmentStatement            shift and go to state 81

state 53

    (47) andExpression -> equalityExpression .
    (44) equalityExpression -> equalityExpression . eqop relationalExpression
    (45) eqop -> . EQEQ
    (46) eqop -> . NEQ

    AND             reduce using rule 47 (andExpression -> equalityExpression .)
    QUESTION        reduce using rule 47 (andExpression -> equalityExpression .)
    OR              reduce using rule 47 (andExpression -> equalityExpression .)
    RPAREN          reduce using rule 47 (andExpression -> equalityExpression .)
    COMMA           reduce using rule 47 (andExpression -> equalityExpression .)
    SEMICOLON       reduce using rule 47 (andExpression -> equalityExpression .)
    RBRACKET        reduce using rule 47 (andExpression -> equalityExpression .)
    COLON           reduce using rule 47 (andExpression -> equalityExpression .)
    EQEQ            shift and go to state 82
    NEQ             shift and go to state 84

    eqop                           shift and go to state 83

state 54

    (23) unaryExpression -> unop . unaryExpression
    (23) unaryExpression -> . unop unaryExpression
    (24) unaryExpression -> . postfixExpression
    (25) unop -> . PLUS
    (26) unop -> . MINUS
    (27) unop -> . EXCLAMATION
    (28) unop -> . TILDE
    (17) postfixExpression -> . constant
    (18) postfixExpression -> . identifier
    (19) postfixExpression -> . LPAREN expression RPAREN
    (21) postfixExpression -> . postfixExpression LBRACKET expression RBRACKET
    (22) postfixExpression -> . IDENT LPAREN expressionlist RPAREN
    (14) constant -> . NUMBER
    (15) constant -> . TRUE
    (16) constant -> . FALSE
    (20) identifier -> . IDENT

    PLUS            shift and go to state 59
    MINUS           shift and go to state 57
    EXCLAMATION     shift and go to state 64
    TILDE           shift and go to state 60
    LPAREN          shift and go to state 38
    IDENT           shift and go to state 56
    NUMBER          shift and go to state 30
    TRUE            shift and go to state 31
    FALSE           shift and go to state 42

    unop                           shift and go to state 54
    postfixExpression              shift and go to state 67
    constant                       shift and go to state 29
    unaryExpression                shift and go to state 85
    identifier                     shift and go to state 44

state 55

    (33) additiveExpression -> multiplicativeExpression .
    (30) multiplicativeExpression -> multiplicativeExpression . multop unaryExpression
    (31) multop -> . TIMES
    (32) multop -> . DIV

    PLUS            reduce using rule 33 (additiveExpression -> multiplicativeExpression .)
    MINUS           reduce using rule 33 (additiveExpression -> multiplicativeExpression .)
    LT              reduce using rule 33 (additiveExpression -> multiplicativeExpression .)
    LEQ             reduce using rule 33 (additiveExpression -> multiplicativeExpression .)
    GT              reduce using rule 33 (additiveExpression -> multiplicativeExpression .)
    GEQ             reduce using rule 33 (additiveExpression -> multiplicativeExpression .)
    EQEQ            reduce using rule 33 (additiveExpression -> multiplicativeExpression .)
    NEQ             reduce using rule 33 (additiveExpression -> multiplicativeExpression .)
    AND             reduce using rule 33 (additiveExpression -> multiplicativeExpression .)
    QUESTION        reduce using rule 33 (additiveExpression -> multiplicativeExpression .)
    OR              reduce using rule 33 (additiveExpression -> multiplicativeExpression .)
    SEMICOLON       reduce using rule 33 (additiveExpression -> multiplicativeExpression .)
    RPAREN          reduce using rule 33 (additiveExpression -> multiplicativeExpression .)
    COMMA           reduce using rule 33 (additiveExpression -> multiplicativeExpression .)
    RBRACKET        reduce using rule 33 (additiveExpression -> multiplicativeExpression .)
    COLON           reduce using rule 33 (additiveExpression -> multiplicativeExpression .)
    TIMES           shift and go to state 88
    DIV             shift and go to state 86

    multop                         shift and go to state 87

state 56

    (22) postfixExpression -> IDENT . LPAREN expressionlist RPAREN
    (20) identifier -> IDENT .

    LPAREN          shift and go to state 49
    LBRACKET        reduce using rule 20 (identifier -> IDENT .)
    TIMES           reduce using rule 20 (identifier -> IDENT .)
    DIV             reduce using rule 20 (identifier -> IDENT .)
    PLUS            reduce using rule 20 (identifier -> IDENT .)
    MINUS           reduce using rule 20 (identifier -> IDENT .)
    LT              reduce using rule 20 (identifier -> IDENT .)
    LEQ             reduce using rule 20 (identifier -> IDENT .)
    GT              reduce using rule 20 (identifier -> IDENT .)
    GEQ             reduce using rule 20 (identifier -> IDENT .)
    EQEQ            reduce using rule 20 (identifier -> IDENT .)
    NEQ             reduce using rule 20 (identifier -> IDENT .)
    AND             reduce using rule 20 (identifier -> IDENT .)
    QUESTION        reduce using rule 20 (identifier -> IDENT .)
    OR              reduce using rule 20 (identifier -> IDENT .)
    RPAREN          reduce using rule 20 (identifier -> IDENT .)
    COMMA           reduce using rule 20 (identifier -> IDENT .)
    SEMICOLON       reduce using rule 20 (identifier -> IDENT .)
    RBRACKET        reduce using rule 20 (identifier -> IDENT .)
    COLON           reduce using rule 20 (identifier -> IDENT .)


state 57

    (26) unop -> MINUS .

    PLUS            reduce using rule 26 (unop -> MINUS .)
    MINUS           reduce using rule 26 (unop -> MINUS .)
    EXCLAMATION     reduce using rule 26 (unop -> MINUS .)
    TILDE           reduce using rule 26 (unop -> MINUS .)
    LPAREN          reduce using rule 26 (unop -> MINUS .)
    IDENT           reduce using rule 26 (unop -> MINUS .)
    NUMBER          reduce using rule 26 (unop -> MINUS .)
    TRUE            reduce using rule 26 (unop -> MINUS .)
    FALSE           reduce using rule 26 (unop -> MINUS .)


state 58

    (51) conditionalExpression -> orExpression .
    (52) conditionalExpression -> orExpression . QUESTION expression COLON expression
    (50) orExpression -> orExpression . OR andExpression

    RBRACKET        reduce using rule 51 (conditionalExpression -> orExpression .)
    SEMICOLON       reduce using rule 51 (conditionalExpression -> orExpression .)
    RPAREN          reduce using rule 51 (conditionalExpression -> orExpression .)
    COMMA           reduce using rule 51 (conditionalExpression -> orExpression .)
    COLON           reduce using rule 51 (conditionalExpression -> orExpression .)
    QUESTION        shift and go to state 89
    OR              shift and go to state 90


state 59

    (25) unop -> PLUS .

    PLUS            reduce using rule 25 (unop -> PLUS .)
    MINUS           reduce using rule 25 (unop -> PLUS .)
    EXCLAMATION     reduce using rule 25 (unop -> PLUS .)
    TILDE           reduce using rule 25 (unop -> PLUS .)
    LPAREN          reduce using rule 25 (unop -> PLUS .)
    IDENT           reduce using rule 25 (unop -> PLUS .)
    NUMBER          reduce using rule 25 (unop -> PLUS .)
    TRUE            reduce using rule 25 (unop -> PLUS .)
    FALSE           reduce using rule 25 (unop -> PLUS .)


state 60

    (28) unop -> TILDE .

    PLUS            reduce using rule 28 (unop -> TILDE .)
    MINUS           reduce using rule 28 (unop -> TILDE .)
    EXCLAMATION     reduce using rule 28 (unop -> TILDE .)
    TILDE           reduce using rule 28 (unop -> TILDE .)
    LPAREN          reduce using rule 28 (unop -> TILDE .)
    IDENT           reduce using rule 28 (unop -> TILDE .)
    NUMBER          reduce using rule 28 (unop -> TILDE .)
    TRUE            reduce using rule 28 (unop -> TILDE .)
    FALSE           reduce using rule 28 (unop -> TILDE .)


state 61

    (37) relationalExpression -> additiveExpression .
    (34) additiveExpression -> additiveExpression . addop multiplicativeExpression
    (35) addop -> . PLUS
    (36) addop -> . MINUS

    LT              reduce using rule 37 (relationalExpression -> additiveExpression .)
    LEQ             reduce using rule 37 (relationalExpression -> additiveExpression .)
    GT              reduce using rule 37 (relationalExpression -> additiveExpression .)
    GEQ             reduce using rule 37 (relationalExpression -> additiveExpression .)
    EQEQ            reduce using rule 37 (relationalExpression -> additiveExpression .)
    NEQ             reduce using rule 37 (relationalExpression -> additiveExpression .)
    AND             reduce using rule 37 (relationalExpression -> additiveExpression .)
    QUESTION        reduce using rule 37 (relationalExpression -> additiveExpression .)
    OR              reduce using rule 37 (relationalExpression -> additiveExpression .)
    RPAREN          reduce using rule 37 (relationalExpression -> additiveExpression .)
    COMMA           reduce using rule 37 (relationalExpression -> additiveExpression .)
    SEMICOLON       reduce using rule 37 (relationalExpression -> additiveExpression .)
    RBRACKET        reduce using rule 37 (relationalExpression -> additiveExpression .)
    COLON           reduce using rule 37 (relationalExpression -> additiveExpression .)
    PLUS            shift and go to state 92
    MINUS           shift and go to state 93

    addop                          shift and go to state 91

state 62

    (53) expression -> conditionalExpression .

    RBRACKET        reduce using rule 53 (expression -> conditionalExpression .)
    SEMICOLON       reduce using rule 53 (expression -> conditionalExpression .)
    RPAREN          reduce using rule 53 (expression -> conditionalExpression .)
    COMMA           reduce using rule 53 (expression -> conditionalExpression .)
    COLON           reduce using rule 53 (expression -> conditionalExpression .)


state 63

    (29) multiplicativeExpression -> unaryExpression .

    TIMES           reduce using rule 29 (multiplicativeExpression -> unaryExpression .)
    DIV             reduce using rule 29 (multiplicativeExpression -> unaryExpression .)
    PLUS            reduce using rule 29 (multiplicativeExpression -> unaryExpression .)
    MINUS           reduce using rule 29 (multiplicativeExpression -> unaryExpression .)
    LT              reduce using rule 29 (multiplicativeExpression -> unaryExpression .)
    LEQ             reduce using rule 29 (multiplicativeExpression -> unaryExpression .)
    GT              reduce using rule 29 (multiplicativeExpression -> unaryExpression .)
    GEQ             reduce using rule 29 (multiplicativeExpression -> unaryExpression .)
    EQEQ            reduce using rule 29 (multiplicativeExpression -> unaryExpression .)
    NEQ             reduce using rule 29 (multiplicativeExpression -> unaryExpression .)
    AND             reduce using rule 29 (multiplicativeExpression -> unaryExpression .)
    QUESTION        reduce using rule 29 (multiplicativeExpression -> unaryExpression .)
    OR              reduce using rule 29 (multiplicativeExpression -> unaryExpression .)
    RPAREN          reduce using rule 29 (multiplicativeExpression -> unaryExpression .)
    COMMA           reduce using rule 29 (multiplicativeExpression -> unaryExpression .)
    SEMICOLON       reduce using rule 29 (multiplicativeExpression -> unaryExpression .)
    RBRACKET        reduce using rule 29 (multiplicativeExpression -> unaryExpression .)
    COLON           reduce using rule 29 (multiplicativeExpression -> unaryExpression .)


state 64

    (27) unop -> EXCLAMATION .

    PLUS            reduce using rule 27 (unop -> EXCLAMATION .)
    MINUS           reduce using rule 27 (unop -> EXCLAMATION .)
    EXCLAMATION     reduce using rule 27 (unop -> EXCLAMATION .)
    TILDE           reduce using rule 27 (unop -> EXCLAMATION .)
    LPAREN          reduce using rule 27 (unop -> EXCLAMATION .)
    IDENT           reduce using rule 27 (unop -> EXCLAMATION .)
    NUMBER          reduce using rule 27 (unop -> EXCLAMATION .)
    TRUE            reduce using rule 27 (unop -> EXCLAMATION .)
    FALSE           reduce using rule 27 (unop -> EXCLAMATION .)


state 65

    (43) equalityExpression -> relationalExpression .
    (38) relationalExpression -> relationalExpression . compop additiveExpression
    (39) compop -> . LT
    (40) compop -> . LEQ
    (41) compop -> . GT
    (42) compop -> . GEQ

    EQEQ            reduce using rule 43 (equalityExpression -> relationalExpression .)
    NEQ             reduce using rule 43 (equalityExpression -> relationalExpression .)
    AND             reduce using rule 43 (equalityExpression -> relationalExpression .)
    QUESTION        reduce using rule 43 (equalityExpression -> relationalExpression .)
    OR              reduce using rule 43 (equalityExpression -> relationalExpression .)
    SEMICOLON       reduce using rule 43 (equalityExpression -> relationalExpression .)
    RPAREN          reduce using rule 43 (equalityExpression -> relationalExpression .)
    COMMA           reduce using rule 43 (equalityExpression -> relationalExpression .)
    RBRACKET        reduce using rule 43 (equalityExpression -> relationalExpression .)
    COLON           reduce using rule 43 (equalityExpression -> relationalExpression .)
    LT              shift and go to state 98
    LEQ             shift and go to state 96
    GT              shift and go to state 95
    GEQ             shift and go to state 94

    compop                         shift and go to state 97

state 66

    (49) orExpression -> andExpression .
    (48) andExpression -> andExpression . AND equalityExpression

    QUESTION        reduce using rule 49 (orExpression -> andExpression .)
    OR              reduce using rule 49 (orExpression -> andExpression .)
    RPAREN          reduce using rule 49 (orExpression -> andExpression .)
    COMMA           reduce using rule 49 (orExpression -> andExpression .)
    SEMICOLON       reduce using rule 49 (orExpression -> andExpression .)
    RBRACKET        reduce using rule 49 (orExpression -> andExpression .)
    COLON           reduce using rule 49 (orExpression -> andExpression .)
    AND             shift and go to state 99


state 67

    (24) unaryExpression -> postfixExpression .
    (21) postfixExpression -> postfixExpression . LBRACKET expression RBRACKET

    TIMES           reduce using rule 24 (unaryExpression -> postfixExpression .)
    DIV             reduce using rule 24 (unaryExpression -> postfixExpression .)
    PLUS            reduce using rule 24 (unaryExpression -> postfixExpression .)
    MINUS           reduce using rule 24 (unaryExpression -> postfixExpression .)
    LT              reduce using rule 24 (unaryExpression -> postfixExpression .)
    LEQ             reduce using rule 24 (unaryExpression -> postfixExpression .)
    GT              reduce using rule 24 (unaryExpression -> postfixExpression .)
    GEQ             reduce using rule 24 (unaryExpression -> postfixExpression .)
    EQEQ            reduce using rule 24 (unaryExpression -> postfixExpression .)
    NEQ             reduce using rule 24 (unaryExpression -> postfixExpression .)
    AND             reduce using rule 24 (unaryExpression -> postfixExpression .)
    QUESTION        reduce using rule 24 (unaryExpression -> postfixExpression .)
    OR              reduce using rule 24 (unaryExpression -> postfixExpression .)
    RPAREN          reduce using rule 24 (unaryExpression -> postfixExpression .)
    COMMA           reduce using rule 24 (unaryExpression -> postfixExpression .)
    SEMICOLON       reduce using rule 24 (unaryExpression -> postfixExpression .)
    RBRACKET        reduce using rule 24 (unaryExpression -> postfixExpression .)
    COLON           reduce using rule 24 (unaryExpression -> postfixExpression .)
    LBRACKET        shift and go to state 71


state 68

    (19) postfixExpression -> LPAREN expression . RPAREN

    RPAREN          shift and go to state 100


state 69

    (69) selectionStatement -> IF LPAREN . expression RPAREN statement ELSE statement
    (70) selectionStatement -> IF LPAREN . expression RPAREN statement
    (53) expression -> . conditionalExpression
    (51) conditionalExpression -> . orExpression
    (52) conditionalExpression -> . orExpression QUESTION expression COLON expression
    (49) orExpression -> . andExpression
    (50) orExpression -> . orExpression OR andExpression
    (47) andExpression -> . equalityExpression
    (48) andExpression -> . andExpression AND equalityExpression
    (43) equalityExpression -> . relationalExpression
    (44) equalityExpression -> . equalityExpression eqop relationalExpression
    (37) relationalExpression -> . additiveExpression
    (38) relationalExpression -> . relationalExpression compop additiveExpression
    (33) additiveExpression -> . multiplicativeExpression
    (34) additiveExpression -> . additiveExpression addop multiplicativeExpression
    (29) multiplicativeExpression -> . unaryExpression
    (30) multiplicativeExpression -> . multiplicativeExpression multop unaryExpression
    (23) unaryExpression -> . unop unaryExpression
    (24) unaryExpression -> . postfixExpression
    (25) unop -> . PLUS
    (26) unop -> . MINUS
    (27) unop -> . EXCLAMATION
    (28) unop -> . TILDE
    (17) postfixExpression -> . constant
    (18) postfixExpression -> . identifier
    (19) postfixExpression -> . LPAREN expression RPAREN
    (21) postfixExpression -> . postfixExpression LBRACKET expression RBRACKET
    (22) postfixExpression -> . IDENT LPAREN expressionlist RPAREN
    (14) constant -> . NUMBER
    (15) constant -> . TRUE
    (16) constant -> . FALSE
    (20) identifier -> . IDENT

    PLUS            shift and go to state 59
    MINUS           shift and go to state 57
    EXCLAMATION     shift and go to state 64
    TILDE           shift and go to state 60
    LPAREN          shift and go to state 38
    IDENT           shift and go to state 56
    NUMBER          shift and go to state 30
    TRUE            shift and go to state 31
    FALSE           shift and go to state 42

    equalityExpression             shift and go to state 53
    additiveExpression             shift and go to state 61
    conditionalExpression          shift and go to state 62
    unaryExpression                shift and go to state 63
    multiplicativeExpression       shift and go to state 55
    orExpression                   shift and go to state 58
    relationalExpression           shift and go to state 65
    unop                           shift and go to state 54
    andExpression                  shift and go to state 66
    postfixExpression              shift and go to state 67
    constant                       shift and go to state 29
    identifier                     shift and go to state 44
    expression                     shift and go to state 101

state 70

    (59) assignmentStatement -> postfixExpression EQ . expression
    (62) assignmentStatement -> postfixExpression EQ . error
    (53) expression -> . conditionalExpression
    (51) conditionalExpression -> . orExpression
    (52) conditionalExpression -> . orExpression QUESTION expression COLON expression
    (49) orExpression -> . andExpression
    (50) orExpression -> . orExpression OR andExpression
    (47) andExpression -> . equalityExpression
    (48) andExpression -> . andExpression AND equalityExpression
    (43) equalityExpression -> . relationalExpression
    (44) equalityExpression -> . equalityExpression eqop relationalExpression
    (37) relationalExpression -> . additiveExpression
    (38) relationalExpression -> . relationalExpression compop additiveExpression
    (33) additiveExpression -> . multiplicativeExpression
    (34) additiveExpression -> . additiveExpression addop multiplicativeExpression
    (29) multiplicativeExpression -> . unaryExpression
    (30) multiplicativeExpression -> . multiplicativeExpression multop unaryExpression
    (23) unaryExpression -> . unop unaryExpression
    (24) unaryExpression -> . postfixExpression
    (25) unop -> . PLUS
    (26) unop -> . MINUS
    (27) unop -> . EXCLAMATION
    (28) unop -> . TILDE
    (17) postfixExpression -> . constant
    (18) postfixExpression -> . identifier
    (19) postfixExpression -> . LPAREN expression RPAREN
    (21) postfixExpression -> . postfixExpression LBRACKET expression RBRACKET
    (22) postfixExpression -> . IDENT LPAREN expressionlist RPAREN
    (14) constant -> . NUMBER
    (15) constant -> . TRUE
    (16) constant -> . FALSE
    (20) identifier -> . IDENT

    error           shift and go to state 102
    PLUS            shift and go to state 59
    MINUS           shift and go to state 57
    EXCLAMATION     shift and go to state 64
    TILDE           shift and go to state 60
    LPAREN          shift and go to state 38
    IDENT           shift and go to state 56
    NUMBER          shift and go to state 30
    TRUE            shift and go to state 31
    FALSE           shift and go to state 42

    postfixExpression              shift and go to state 67
    equalityExpression             shift and go to state 53
    conditionalExpression          shift and go to state 62
    unaryExpression                shift and go to state 63
    identifier                     shift and go to state 44
    multiplicativeExpression       shift and go to state 55
    orExpression                   shift and go to state 58
    relationalExpression           shift and go to state 65
    unop                           shift and go to state 54
    andExpression                  shift and go to state 66
    constant                       shift and go to state 29
    additiveExpression             shift and go to state 61
    expression                     shift and go to state 103

state 71

    (21) postfixExpression -> postfixExpression LBRACKET . expression RBRACKET
    (53) expression -> . conditionalExpression
    (51) conditionalExpression -> . orExpression
    (52) conditionalExpression -> . orExpression QUESTION expression COLON expression
    (49) orExpression -> . andExpression
    (50) orExpression -> . orExpression OR andExpression
    (47) andExpression -> . equalityExpression
    (48) andExpression -> . andExpression AND equalityExpression
    (43) equalityExpression -> . relationalExpression
    (44) equalityExpression -> . equalityExpression eqop relationalExpression
    (37) relationalExpression -> . additiveExpression
    (38) relationalExpression -> . relationalExpression compop additiveExpression
    (33) additiveExpression -> . multiplicativeExpression
    (34) additiveExpression -> . additiveExpression addop multiplicativeExpression
    (29) multiplicativeExpression -> . unaryExpression
    (30) multiplicativeExpression -> . multiplicativeExpression multop unaryExpression
    (23) unaryExpression -> . unop unaryExpression
    (24) unaryExpression -> . postfixExpression
    (25) unop -> . PLUS
    (26) unop -> . MINUS
    (27) unop -> . EXCLAMATION
    (28) unop -> . TILDE
    (17) postfixExpression -> . constant
    (18) postfixExpression -> . identifier
    (19) postfixExpression -> . LPAREN expression RPAREN
    (21) postfixExpression -> . postfixExpression LBRACKET expression RBRACKET
    (22) postfixExpression -> . IDENT LPAREN expressionlist RPAREN
    (14) constant -> . NUMBER
    (15) constant -> . TRUE
    (16) constant -> . FALSE
    (20) identifier -> . IDENT

    PLUS            shift and go to state 59
    MINUS           shift and go to state 57
    EXCLAMATION     shift and go to state 64
    TILDE           shift and go to state 60
    LPAREN          shift and go to state 38
    IDENT           shift and go to state 56
    NUMBER          shift and go to state 30
    TRUE            shift and go to state 31
    FALSE           shift and go to state 42

    postfixExpression              shift and go to state 67
    equalityExpression             shift and go to state 53
    conditionalExpression          shift and go to state 62
    unaryExpression                shift and go to state 63
    identifier                     shift and go to state 44
    multiplicativeExpression       shift and go to state 55
    orExpression                   shift and go to state 58
    relationalExpression           shift and go to state 65
    unop                           shift and go to state 54
    andExpression                  shift and go to state 66
    constant                       shift and go to state 29
    additiveExpression             shift and go to state 61
    expression                     shift and go to state 104

state 72

    (63) assignmentStatement -> error EQ . expression
    (53) expression -> . conditionalExpression
    (51) conditionalExpression -> . orExpression
    (52) conditionalExpression -> . orExpression QUESTION expression COLON expression
    (49) orExpression -> . andExpression
    (50) orExpression -> . orExpression OR andExpression
    (47) andExpression -> . equalityExpression
    (48) andExpression -> . andExpression AND equalityExpression
    (43) equalityExpression -> . relationalExpression
    (44) equalityExpression -> . equalityExpression eqop relationalExpression
    (37) relationalExpression -> . additiveExpression
    (38) relationalExpression -> . relationalExpression compop additiveExpression
    (33) additiveExpression -> . multiplicativeExpression
    (34) additiveExpression -> . additiveExpression addop multiplicativeExpression
    (29) multiplicativeExpression -> . unaryExpression
    (30) multiplicativeExpression -> . multiplicativeExpression multop unaryExpression
    (23) unaryExpression -> . unop unaryExpression
    (24) unaryExpression -> . postfixExpression
    (25) unop -> . PLUS
    (26) unop -> . MINUS
    (27) unop -> . EXCLAMATION
    (28) unop -> . TILDE
    (17) postfixExpression -> . constant
    (18) postfixExpression -> . identifier
    (19) postfixExpression -> . LPAREN expression RPAREN
    (21) postfixExpression -> . postfixExpression LBRACKET expression RBRACKET
    (22) postfixExpression -> . IDENT LPAREN expressionlist RPAREN
    (14) constant -> . NUMBER
    (15) constant -> . TRUE
    (16) constant -> . FALSE
    (20) identifier -> . IDENT

    PLUS            shift and go to state 59
    MINUS           shift and go to state 57
    EXCLAMATION     shift and go to state 64
    TILDE           shift and go to state 60
    LPAREN          shift and go to state 38
    IDENT           shift and go to state 56
    NUMBER          shift and go to state 30
    TRUE            shift and go to state 31
    FALSE           shift and go to state 42

    equalityExpression             shift and go to state 53
    additiveExpression             shift and go to state 61
    conditionalExpression          shift and go to state 62
    unaryExpression                shift and go to state 63
    multiplicativeExpression       shift and go to state 55
    orExpression                   shift and go to state 58
    relationalExpression           shift and go to state 65
    unop                           shift and go to state 54
    andExpression                  shift and go to state 66
    postfixExpression              shift and go to state 67
    constant                       shift and go to state 29
    identifier                     shift and go to state 44
    expression                     shift and go to state 105

state 73

    (68) statement -> error SEMICOLON .

    ELSE            reduce using rule 68 (statement -> error SEMICOLON .)
    RBRACE          reduce using rule 68 (statement -> error SEMICOLON .)
    error           reduce using rule 68 (statement -> error SEMICOLON .)
    IDENT           reduce using rule 68 (statement -> error SEMICOLON .)
    FOR             reduce using rule 68 (statement -> error SEMICOLON .)
    IF              reduce using rule 68 (statement -> error SEMICOLON .)
    LBRACE          reduce using rule 68 (statement -> error SEMICOLON .)
    LPAREN          reduce using rule 68 (statement -> error SEMICOLON .)
    NUMBER          reduce using rule 68 (statement -> error SEMICOLON .)
    TRUE            reduce using rule 68 (statement -> error SEMICOLON .)
    FALSE           reduce using rule 68 (statement -> error SEMICOLON .)


state 74

    (5) sequentialspec -> SEQUENTIAL LPAREN arglist RPAREN RETURNS LPAREN . identlist RPAREN LOCALS LPAREN arglist RPAREN block
    (11) identlist -> . identifier
    (12) identlist -> . identifier COMMA identlist
    (13) identlist -> .
    (20) identifier -> . IDENT

    RPAREN          reduce using rule 13 (identlist -> .)
    IDENT           shift and go to state 108

    identifier                     shift and go to state 107
    identlist                      shift and go to state 106

state 75

    (2) joinspec -> JOIN LPAREN arglist SEPARE arglist RPAREN RETURNS LPAREN . identlist RPAREN LOCALS LPAREN arglist RPAREN block
    (4) joinspec -> JOIN LPAREN arglist SEPARE arglist RPAREN RETURNS LPAREN . identlist RPAREN LOCALS LPAREN arglist RPAREN error
    (11) identlist -> . identifier
    (12) identlist -> . identifier COMMA identlist
    (13) identlist -> .
    (20) identifier -> . IDENT

    RPAREN          reduce using rule 13 (identlist -> .)
    IDENT           shift and go to state 108

    identifier                     shift and go to state 107
    identlist                      shift and go to state 109

state 76

    (22) postfixExpression -> IDENT LPAREN expressionlist . RPAREN
    (55) expressionlist -> expressionlist . COMMA expression

    RPAREN          shift and go to state 110
    COMMA           shift and go to state 111


state 77

    (54) expressionlist -> expression .

    RPAREN          reduce using rule 54 (expressionlist -> expression .)
    COMMA           reduce using rule 54 (expressionlist -> expression .)


state 78

    (60) assignmentStatement -> IDENT PLUS PLUS .

    SEMICOLON       reduce using rule 60 (assignmentStatement -> IDENT PLUS PLUS .)
    RPAREN          reduce using rule 60 (assignmentStatement -> IDENT PLUS PLUS .)


state 79

    (61) assignmentStatement -> IDENT MINUS MINUS .

    SEMICOLON       reduce using rule 61 (assignmentStatement -> IDENT MINUS MINUS .)
    RPAREN          reduce using rule 61 (assignmentStatement -> IDENT MINUS MINUS .)


state 80

    (63) assignmentStatement -> error . EQ expression

    EQ              shift and go to state 72


state 81

    (71) iterationStatement -> FOR LPAREN assignmentStatement . SEMICOLON expression SEMICOLON assignmentStatement RPAREN statement

    SEMICOLON       shift and go to state 112


state 82

    (45) eqop -> EQEQ .

    PLUS            reduce using rule 45 (eqop -> EQEQ .)
    MINUS           reduce using rule 45 (eqop -> EQEQ .)
    EXCLAMATION     reduce using rule 45 (eqop -> EQEQ .)
    TILDE           reduce using rule 45 (eqop -> EQEQ .)
    LPAREN          reduce using rule 45 (eqop -> EQEQ .)
    IDENT           reduce using rule 45 (eqop -> EQEQ .)
    NUMBER          reduce using rule 45 (eqop -> EQEQ .)
    TRUE            reduce using rule 45 (eqop -> EQEQ .)
    FALSE           reduce using rule 45 (eqop -> EQEQ .)


state 83

    (44) equalityExpression -> equalityExpression eqop . relationalExpression
    (37) relationalExpression -> . additiveExpression
    (38) relationalExpression -> . relationalExpression compop additiveExpression
    (33) additiveExpression -> . multiplicativeExpression
    (34) additiveExpression -> . additiveExpression addop multiplicativeExpression
    (29) multiplicativeExpression -> . unaryExpression
    (30) multiplicativeExpression -> . multiplicativeExpression multop unaryExpression
    (23) unaryExpression -> . unop unaryExpression
    (24) unaryExpression -> . postfixExpression
    (25) unop -> . PLUS
    (26) unop -> . MINUS
    (27) unop -> . EXCLAMATION
    (28) unop -> . TILDE
    (17) postfixExpression -> . constant
    (18) postfixExpression -> . identifier
    (19) postfixExpression -> . LPAREN expression RPAREN
    (21) postfixExpression -> . postfixExpression LBRACKET expression RBRACKET
    (22) postfixExpression -> . IDENT LPAREN expressionlist RPAREN
    (14) constant -> . NUMBER
    (15) constant -> . TRUE
    (16) constant -> . FALSE
    (20) identifier -> . IDENT

    PLUS            shift and go to state 59
    MINUS           shift and go to state 57
    EXCLAMATION     shift and go to state 64
    TILDE           shift and go to state 60
    LPAREN          shift and go to state 38
    IDENT           shift and go to state 56
    NUMBER          shift and go to state 30
    TRUE            shift and go to state 31
    FALSE           shift and go to state 42

    additiveExpression             shift and go to state 61
    unaryExpression                shift and go to state 63
    multiplicativeExpression       shift and go to state 55
    relationalExpression           shift and go to state 113
    unop                           shift and go to state 54
    postfixExpression              shift and go to state 67
    constant                       shift and go to state 29
    identifier                     shift and go to state 44

state 84

    (46) eqop -> NEQ .

    PLUS            reduce using rule 46 (eqop -> NEQ .)
    MINUS           reduce using rule 46 (eqop -> NEQ .)
    EXCLAMATION     reduce using rule 46 (eqop -> NEQ .)
    TILDE           reduce using rule 46 (eqop -> NEQ .)
    LPAREN          reduce using rule 46 (eqop -> NEQ .)
    IDENT           reduce using rule 46 (eqop -> NEQ .)
    NUMBER          reduce using rule 46 (eqop -> NEQ .)
    TRUE            reduce using rule 46 (eqop -> NEQ .)
    FALSE           reduce using rule 46 (eqop -> NEQ .)


state 85

    (23) unaryExpression -> unop unaryExpression .

    TIMES           reduce using rule 23 (unaryExpression -> unop unaryExpression .)
    DIV             reduce using rule 23 (unaryExpression -> unop unaryExpression .)
    PLUS            reduce using rule 23 (unaryExpression -> unop unaryExpression .)
    MINUS           reduce using rule 23 (unaryExpression -> unop unaryExpression .)
    LT              reduce using rule 23 (unaryExpression -> unop unaryExpression .)
    LEQ             reduce using rule 23 (unaryExpression -> unop unaryExpression .)
    GT              reduce using rule 23 (unaryExpression -> unop unaryExpression .)
    GEQ             reduce using rule 23 (unaryExpression -> unop unaryExpression .)
    EQEQ            reduce using rule 23 (unaryExpression -> unop unaryExpression .)
    NEQ             reduce using rule 23 (unaryExpression -> unop unaryExpression .)
    AND             reduce using rule 23 (unaryExpression -> unop unaryExpression .)
    QUESTION        reduce using rule 23 (unaryExpression -> unop unaryExpression .)
    OR              reduce using rule 23 (unaryExpression -> unop unaryExpression .)
    RPAREN          reduce using rule 23 (unaryExpression -> unop unaryExpression .)
    COMMA           reduce using rule 23 (unaryExpression -> unop unaryExpression .)
    SEMICOLON       reduce using rule 23 (unaryExpression -> unop unaryExpression .)
    RBRACKET        reduce using rule 23 (unaryExpression -> unop unaryExpression .)
    COLON           reduce using rule 23 (unaryExpression -> unop unaryExpression .)


state 86

    (32) multop -> DIV .

    PLUS            reduce using rule 32 (multop -> DIV .)
    MINUS           reduce using rule 32 (multop -> DIV .)
    EXCLAMATION     reduce using rule 32 (multop -> DIV .)
    TILDE           reduce using rule 32 (multop -> DIV .)
    LPAREN          reduce using rule 32 (multop -> DIV .)
    IDENT           reduce using rule 32 (multop -> DIV .)
    NUMBER          reduce using rule 32 (multop -> DIV .)
    TRUE            reduce using rule 32 (multop -> DIV .)
    FALSE           reduce using rule 32 (multop -> DIV .)


state 87

    (30) multiplicativeExpression -> multiplicativeExpression multop . unaryExpression
    (23) unaryExpression -> . unop unaryExpression
    (24) unaryExpression -> . postfixExpression
    (25) unop -> . PLUS
    (26) unop -> . MINUS
    (27) unop -> . EXCLAMATION
    (28) unop -> . TILDE
    (17) postfixExpression -> . constant
    (18) postfixExpression -> . identifier
    (19) postfixExpression -> . LPAREN expression RPAREN
    (21) postfixExpression -> . postfixExpression LBRACKET expression RBRACKET
    (22) postfixExpression -> . IDENT LPAREN expressionlist RPAREN
    (14) constant -> . NUMBER
    (15) constant -> . TRUE
    (16) constant -> . FALSE
    (20) identifier -> . IDENT

    PLUS            shift and go to state 59
    MINUS           shift and go to state 57
    EXCLAMATION     shift and go to state 64
    TILDE           shift and go to state 60
    LPAREN          shift and go to state 38
    IDENT           shift and go to state 56
    NUMBER          shift and go to state 30
    TRUE            shift and go to state 31
    FALSE           shift and go to state 42

    unop                           shift and go to state 54
    postfixExpression              shift and go to state 67
    constant                       shift and go to state 29
    unaryExpression                shift and go to state 114
    identifier                     shift and go to state 44

state 88

    (31) multop -> TIMES .

    PLUS            reduce using rule 31 (multop -> TIMES .)
    MINUS           reduce using rule 31 (multop -> TIMES .)
    EXCLAMATION     reduce using rule 31 (multop -> TIMES .)
    TILDE           reduce using rule 31 (multop -> TIMES .)
    LPAREN          reduce using rule 31 (multop -> TIMES .)
    IDENT           reduce using rule 31 (multop -> TIMES .)
    NUMBER          reduce using rule 31 (multop -> TIMES .)
    TRUE            reduce using rule 31 (multop -> TIMES .)
    FALSE           reduce using rule 31 (multop -> TIMES .)


state 89

    (52) conditionalExpression -> orExpression QUESTION . expression COLON expression
    (53) expression -> . conditionalExpression
    (51) conditionalExpression -> . orExpression
    (52) conditionalExpression -> . orExpression QUESTION expression COLON expression
    (49) orExpression -> . andExpression
    (50) orExpression -> . orExpression OR andExpression
    (47) andExpression -> . equalityExpression
    (48) andExpression -> . andExpression AND equalityExpression
    (43) equalityExpression -> . relationalExpression
    (44) equalityExpression -> . equalityExpression eqop relationalExpression
    (37) relationalExpression -> . additiveExpression
    (38) relationalExpression -> . relationalExpression compop additiveExpression
    (33) additiveExpression -> . multiplicativeExpression
    (34) additiveExpression -> . additiveExpression addop multiplicativeExpression
    (29) multiplicativeExpression -> . unaryExpression
    (30) multiplicativeExpression -> . multiplicativeExpression multop unaryExpression
    (23) unaryExpression -> . unop unaryExpression
    (24) unaryExpression -> . postfixExpression
    (25) unop -> . PLUS
    (26) unop -> . MINUS
    (27) unop -> . EXCLAMATION
    (28) unop -> . TILDE
    (17) postfixExpression -> . constant
    (18) postfixExpression -> . identifier
    (19) postfixExpression -> . LPAREN expression RPAREN
    (21) postfixExpression -> . postfixExpression LBRACKET expression RBRACKET
    (22) postfixExpression -> . IDENT LPAREN expressionlist RPAREN
    (14) constant -> . NUMBER
    (15) constant -> . TRUE
    (16) constant -> . FALSE
    (20) identifier -> . IDENT

    PLUS            shift and go to state 59
    MINUS           shift and go to state 57
    EXCLAMATION     shift and go to state 64
    TILDE           shift and go to state 60
    LPAREN          shift and go to state 38
    IDENT           shift and go to state 56
    NUMBER          shift and go to state 30
    TRUE            shift and go to state 31
    FALSE           shift and go to state 42

    equalityExpression             shift and go to state 53
    additiveExpression             shift and go to state 61
    conditionalExpression          shift and go to state 62
    unaryExpression                shift and go to state 63
    multiplicativeExpression       shift and go to state 55
    orExpression                   shift and go to state 58
    relationalExpression           shift and go to state 65
    unop                           shift and go to state 54
    andExpression                  shift and go to state 66
    postfixExpression              shift and go to state 67
    constant                       shift and go to state 29
    identifier                     shift and go to state 44
    expression                     shift and go to state 115

state 90

    (50) orExpression -> orExpression OR . andExpression
    (47) andExpression -> . equalityExpression
    (48) andExpression -> . andExpression AND equalityExpression
    (43) equalityExpression -> . relationalExpression
    (44) equalityExpression -> . equalityExpression eqop relationalExpression
    (37) relationalExpression -> . additiveExpression
    (38) relationalExpression -> . relationalExpression compop additiveExpression
    (33) additiveExpression -> . multiplicativeExpression
    (34) additiveExpression -> . additiveExpression addop multiplicativeExpression
    (29) multiplicativeExpression -> . unaryExpression
    (30) multiplicativeExpression -> . multiplicativeExpression multop unaryExpression
    (23) unaryExpression -> . unop unaryExpression
    (24) unaryExpression -> . postfixExpression
    (25) unop -> . PLUS
    (26) unop -> . MINUS
    (27) unop -> . EXCLAMATION
    (28) unop -> . TILDE
    (17) postfixExpression -> . constant
    (18) postfixExpression -> . identifier
    (19) postfixExpression -> . LPAREN expression RPAREN
    (21) postfixExpression -> . postfixExpression LBRACKET expression RBRACKET
    (22) postfixExpression -> . IDENT LPAREN expressionlist RPAREN
    (14) constant -> . NUMBER
    (15) constant -> . TRUE
    (16) constant -> . FALSE
    (20) identifier -> . IDENT

    PLUS            shift and go to state 59
    MINUS           shift and go to state 57
    EXCLAMATION     shift and go to state 64
    TILDE           shift and go to state 60
    LPAREN          shift and go to state 38
    IDENT           shift and go to state 56
    NUMBER          shift and go to state 30
    TRUE            shift and go to state 31
    FALSE           shift and go to state 42

    equalityExpression             shift and go to state 53
    additiveExpression             shift and go to state 61
    unaryExpression                shift and go to state 63
    multiplicativeExpression       shift and go to state 55
    relationalExpression           shift and go to state 65
    unop                           shift and go to state 54
    andExpression                  shift and go to state 116
    postfixExpression              shift and go to state 67
    constant                       shift and go to state 29
    identifier                     shift and go to state 44

state 91

    (34) additiveExpression -> additiveExpression addop . multiplicativeExpression
    (29) multiplicativeExpression -> . unaryExpression
    (30) multiplicativeExpression -> . multiplicativeExpression multop unaryExpression
    (23) unaryExpression -> . unop unaryExpression
    (24) unaryExpression -> . postfixExpression
    (25) unop -> . PLUS
    (26) unop -> . MINUS
    (27) unop -> . EXCLAMATION
    (28) unop -> . TILDE
    (17) postfixExpression -> . constant
    (18) postfixExpression -> . identifier
    (19) postfixExpression -> . LPAREN expression RPAREN
    (21) postfixExpression -> . postfixExpression LBRACKET expression RBRACKET
    (22) postfixExpression -> . IDENT LPAREN expressionlist RPAREN
    (14) constant -> . NUMBER
    (15) constant -> . TRUE
    (16) constant -> . FALSE
    (20) identifier -> . IDENT

    PLUS            shift and go to state 59
    MINUS           shift and go to state 57
    EXCLAMATION     shift and go to state 64
    TILDE           shift and go to state 60
    LPAREN          shift and go to state 38
    IDENT           shift and go to state 56
    NUMBER          shift and go to state 30
    TRUE            shift and go to state 31
    FALSE           shift and go to state 42

    unaryExpression                shift and go to state 63
    multiplicativeExpression       shift and go to state 117
    unop                           shift and go to state 54
    postfixExpression              shift and go to state 67
    constant                       shift and go to state 29
    identifier                     shift and go to state 44

state 92

    (35) addop -> PLUS .

    PLUS            reduce using rule 35 (addop -> PLUS .)
    MINUS           reduce using rule 35 (addop -> PLUS .)
    EXCLAMATION     reduce using rule 35 (addop -> PLUS .)
    TILDE           reduce using rule 35 (addop -> PLUS .)
    LPAREN          reduce using rule 35 (addop -> PLUS .)
    IDENT           reduce using rule 35 (addop -> PLUS .)
    NUMBER          reduce using rule 35 (addop -> PLUS .)
    TRUE            reduce using rule 35 (addop -> PLUS .)
    FALSE           reduce using rule 35 (addop -> PLUS .)


state 93

    (36) addop -> MINUS .

    PLUS            reduce using rule 36 (addop -> MINUS .)
    MINUS           reduce using rule 36 (addop -> MINUS .)
    EXCLAMATION     reduce using rule 36 (addop -> MINUS .)
    TILDE           reduce using rule 36 (addop -> MINUS .)
    LPAREN          reduce using rule 36 (addop -> MINUS .)
    IDENT           reduce using rule 36 (addop -> MINUS .)
    NUMBER          reduce using rule 36 (addop -> MINUS .)
    TRUE            reduce using rule 36 (addop -> MINUS .)
    FALSE           reduce using rule 36 (addop -> MINUS .)


state 94

    (42) compop -> GEQ .

    PLUS            reduce using rule 42 (compop -> GEQ .)
    MINUS           reduce using rule 42 (compop -> GEQ .)
    EXCLAMATION     reduce using rule 42 (compop -> GEQ .)
    TILDE           reduce using rule 42 (compop -> GEQ .)
    LPAREN          reduce using rule 42 (compop -> GEQ .)
    IDENT           reduce using rule 42 (compop -> GEQ .)
    NUMBER          reduce using rule 42 (compop -> GEQ .)
    TRUE            reduce using rule 42 (compop -> GEQ .)
    FALSE           reduce using rule 42 (compop -> GEQ .)


state 95

    (41) compop -> GT .

    PLUS            reduce using rule 41 (compop -> GT .)
    MINUS           reduce using rule 41 (compop -> GT .)
    EXCLAMATION     reduce using rule 41 (compop -> GT .)
    TILDE           reduce using rule 41 (compop -> GT .)
    LPAREN          reduce using rule 41 (compop -> GT .)
    IDENT           reduce using rule 41 (compop -> GT .)
    NUMBER          reduce using rule 41 (compop -> GT .)
    TRUE            reduce using rule 41 (compop -> GT .)
    FALSE           reduce using rule 41 (compop -> GT .)


state 96

    (40) compop -> LEQ .

    PLUS            reduce using rule 40 (compop -> LEQ .)
    MINUS           reduce using rule 40 (compop -> LEQ .)
    EXCLAMATION     reduce using rule 40 (compop -> LEQ .)
    TILDE           reduce using rule 40 (compop -> LEQ .)
    LPAREN          reduce using rule 40 (compop -> LEQ .)
    IDENT           reduce using rule 40 (compop -> LEQ .)
    NUMBER          reduce using rule 40 (compop -> LEQ .)
    TRUE            reduce using rule 40 (compop -> LEQ .)
    FALSE           reduce using rule 40 (compop -> LEQ .)


state 97

    (38) relationalExpression -> relationalExpression compop . additiveExpression
    (33) additiveExpression -> . multiplicativeExpression
    (34) additiveExpression -> . additiveExpression addop multiplicativeExpression
    (29) multiplicativeExpression -> . unaryExpression
    (30) multiplicativeExpression -> . multiplicativeExpression multop unaryExpression
    (23) unaryExpression -> . unop unaryExpression
    (24) unaryExpression -> . postfixExpression
    (25) unop -> . PLUS
    (26) unop -> . MINUS
    (27) unop -> . EXCLAMATION
    (28) unop -> . TILDE
    (17) postfixExpression -> . constant
    (18) postfixExpression -> . identifier
    (19) postfixExpression -> . LPAREN expression RPAREN
    (21) postfixExpression -> . postfixExpression LBRACKET expression RBRACKET
    (22) postfixExpression -> . IDENT LPAREN expressionlist RPAREN
    (14) constant -> . NUMBER
    (15) constant -> . TRUE
    (16) constant -> . FALSE
    (20) identifier -> . IDENT

    PLUS            shift and go to state 59
    MINUS           shift and go to state 57
    EXCLAMATION     shift and go to state 64
    TILDE           shift and go to state 60
    LPAREN          shift and go to state 38
    IDENT           shift and go to state 56
    NUMBER          shift and go to state 30
    TRUE            shift and go to state 31
    FALSE           shift and go to state 42

    additiveExpression             shift and go to state 118
    unaryExpression                shift and go to state 63
    multiplicativeExpression       shift and go to state 55
    unop                           shift and go to state 54
    postfixExpression              shift and go to state 67
    constant                       shift and go to state 29
    identifier                     shift and go to state 44

state 98

    (39) compop -> LT .

    PLUS            reduce using rule 39 (compop -> LT .)
    MINUS           reduce using rule 39 (compop -> LT .)
    EXCLAMATION     reduce using rule 39 (compop -> LT .)
    TILDE           reduce using rule 39 (compop -> LT .)
    LPAREN          reduce using rule 39 (compop -> LT .)
    IDENT           reduce using rule 39 (compop -> LT .)
    NUMBER          reduce using rule 39 (compop -> LT .)
    TRUE            reduce using rule 39 (compop -> LT .)
    FALSE           reduce using rule 39 (compop -> LT .)


state 99

    (48) andExpression -> andExpression AND . equalityExpression
    (43) equalityExpression -> . relationalExpression
    (44) equalityExpression -> . equalityExpression eqop relationalExpression
    (37) relationalExpression -> . additiveExpression
    (38) relationalExpression -> . relationalExpression compop additiveExpression
    (33) additiveExpression -> . multiplicativeExpression
    (34) additiveExpression -> . additiveExpression addop multiplicativeExpression
    (29) multiplicativeExpression -> . unaryExpression
    (30) multiplicativeExpression -> . multiplicativeExpression multop unaryExpression
    (23) unaryExpression -> . unop unaryExpression
    (24) unaryExpression -> . postfixExpression
    (25) unop -> . PLUS
    (26) unop -> . MINUS
    (27) unop -> . EXCLAMATION
    (28) unop -> . TILDE
    (17) postfixExpression -> . constant
    (18) postfixExpression -> . identifier
    (19) postfixExpression -> . LPAREN expression RPAREN
    (21) postfixExpression -> . postfixExpression LBRACKET expression RBRACKET
    (22) postfixExpression -> . IDENT LPAREN expressionlist RPAREN
    (14) constant -> . NUMBER
    (15) constant -> . TRUE
    (16) constant -> . FALSE
    (20) identifier -> . IDENT

    PLUS            shift and go to state 59
    MINUS           shift and go to state 57
    EXCLAMATION     shift and go to state 64
    TILDE           shift and go to state 60
    LPAREN          shift and go to state 38
    IDENT           shift and go to state 56
    NUMBER          shift and go to state 30
    TRUE            shift and go to state 31
    FALSE           shift and go to state 42

    equalityExpression             shift and go to state 119
    additiveExpression             shift and go to state 61
    unaryExpression                shift and go to state 63
    multiplicativeExpression       shift and go to state 55
    relationalExpression           shift and go to state 65
    unop                           shift and go to state 54
    postfixExpression              shift and go to state 67
    constant                       shift and go to state 29
    identifier                     shift and go to state 44

state 100

    (19) postfixExpression -> LPAREN expression RPAREN .

    LBRACKET        reduce using rule 19 (postfixExpression -> LPAREN expression RPAREN .)
    TIMES           reduce using rule 19 (postfixExpression -> LPAREN expression RPAREN .)
    DIV             reduce using rule 19 (postfixExpression -> LPAREN expression RPAREN .)
    PLUS            reduce using rule 19 (postfixExpression -> LPAREN expression RPAREN .)
    MINUS           reduce using rule 19 (postfixExpression -> LPAREN expression RPAREN .)
    LT              reduce using rule 19 (postfixExpression -> LPAREN expression RPAREN .)
    LEQ             reduce using rule 19 (postfixExpression -> LPAREN expression RPAREN .)
    GT              reduce using rule 19 (postfixExpression -> LPAREN expression RPAREN .)
    GEQ             reduce using rule 19 (postfixExpression -> LPAREN expression RPAREN .)
    EQEQ            reduce using rule 19 (postfixExpression -> LPAREN expression RPAREN .)
    NEQ             reduce using rule 19 (postfixExpression -> LPAREN expression RPAREN .)
    AND             reduce using rule 19 (postfixExpression -> LPAREN expression RPAREN .)
    QUESTION        reduce using rule 19 (postfixExpression -> LPAREN expression RPAREN .)
    OR              reduce using rule 19 (postfixExpression -> LPAREN expression RPAREN .)
    SEMICOLON       reduce using rule 19 (postfixExpression -> LPAREN expression RPAREN .)
    RPAREN          reduce using rule 19 (postfixExpression -> LPAREN expression RPAREN .)
    COMMA           reduce using rule 19 (postfixExpression -> LPAREN expression RPAREN .)
    RBRACKET        reduce using rule 19 (postfixExpression -> LPAREN expression RPAREN .)
    COLON           reduce using rule 19 (postfixExpression -> LPAREN expression RPAREN .)
    EQ              reduce using rule 19 (postfixExpression -> LPAREN expression RPAREN .)


state 101

    (69) selectionStatement -> IF LPAREN expression . RPAREN statement ELSE statement
    (70) selectionStatement -> IF LPAREN expression . RPAREN statement

    RPAREN          shift and go to state 120


state 102

    (62) assignmentStatement -> postfixExpression EQ error .

    SEMICOLON       reduce using rule 62 (assignmentStatement -> postfixExpression EQ error .)
    RPAREN          reduce using rule 62 (assignmentStatement -> postfixExpression EQ error .)


state 103

    (59) assignmentStatement -> postfixExpression EQ expression .

    SEMICOLON       reduce using rule 59 (assignmentStatement -> postfixExpression EQ expression .)
    RPAREN          reduce using rule 59 (assignmentStatement -> postfixExpression EQ expression .)


state 104

    (21) postfixExpression -> postfixExpression LBRACKET expression . RBRACKET

    RBRACKET        shift and go to state 121


state 105

    (63) assignmentStatement -> error EQ expression .

    SEMICOLON       reduce using rule 63 (assignmentStatement -> error EQ expression .)
    RPAREN          reduce using rule 63 (assignmentStatement -> error EQ expression .)


state 106

    (5) sequentialspec -> SEQUENTIAL LPAREN arglist RPAREN RETURNS LPAREN identlist . RPAREN LOCALS LPAREN arglist RPAREN block

    RPAREN          shift and go to state 122


state 107

    (11) identlist -> identifier .
    (12) identlist -> identifier . COMMA identlist

    RPAREN          reduce using rule 11 (identlist -> identifier .)
    COMMA           shift and go to state 123


state 108

    (20) identifier -> IDENT .

    COMMA           reduce using rule 20 (identifier -> IDENT .)
    RPAREN          reduce using rule 20 (identifier -> IDENT .)


state 109

    (2) joinspec -> JOIN LPAREN arglist SEPARE arglist RPAREN RETURNS LPAREN identlist . RPAREN LOCALS LPAREN arglist RPAREN block
    (4) joinspec -> JOIN LPAREN arglist SEPARE arglist RPAREN RETURNS LPAREN identlist . RPAREN LOCALS LPAREN arglist RPAREN error

    RPAREN          shift and go to state 124


state 110

    (22) postfixExpression -> IDENT LPAREN expressionlist RPAREN .

    LBRACKET        reduce using rule 22 (postfixExpression -> IDENT LPAREN expressionlist RPAREN .)
    TIMES           reduce using rule 22 (postfixExpression -> IDENT LPAREN expressionlist RPAREN .)
    DIV             reduce using rule 22 (postfixExpression -> IDENT LPAREN expressionlist RPAREN .)
    PLUS            reduce using rule 22 (postfixExpression -> IDENT LPAREN expressionlist RPAREN .)
    MINUS           reduce using rule 22 (postfixExpression -> IDENT LPAREN expressionlist RPAREN .)
    LT              reduce using rule 22 (postfixExpression -> IDENT LPAREN expressionlist RPAREN .)
    LEQ             reduce using rule 22 (postfixExpression -> IDENT LPAREN expressionlist RPAREN .)
    GT              reduce using rule 22 (postfixExpression -> IDENT LPAREN expressionlist RPAREN .)
    GEQ             reduce using rule 22 (postfixExpression -> IDENT LPAREN expressionlist RPAREN .)
    EQEQ            reduce using rule 22 (postfixExpression -> IDENT LPAREN expressionlist RPAREN .)
    NEQ             reduce using rule 22 (postfixExpression -> IDENT LPAREN expressionlist RPAREN .)
    AND             reduce using rule 22 (postfixExpression -> IDENT LPAREN expressionlist RPAREN .)
    QUESTION        reduce using rule 22 (postfixExpression -> IDENT LPAREN expressionlist RPAREN .)
    OR              reduce using rule 22 (postfixExpression -> IDENT LPAREN expressionlist RPAREN .)
    SEMICOLON       reduce using rule 22 (postfixExpression -> IDENT LPAREN expressionlist RPAREN .)
    RPAREN          reduce using rule 22 (postfixExpression -> IDENT LPAREN expressionlist RPAREN .)
    COMMA           reduce using rule 22 (postfixExpression -> IDENT LPAREN expressionlist RPAREN .)
    RBRACKET        reduce using rule 22 (postfixExpression -> IDENT LPAREN expressionlist RPAREN .)
    COLON           reduce using rule 22 (postfixExpression -> IDENT LPAREN expressionlist RPAREN .)
    EQ              reduce using rule 22 (postfixExpression -> IDENT LPAREN expressionlist RPAREN .)


state 111

    (55) expressionlist -> expressionlist COMMA . expression
    (53) expression -> . conditionalExpression
    (51) conditionalExpression -> . orExpression
    (52) conditionalExpression -> . orExpression QUESTION expression COLON expression
    (49) orExpression -> . andExpression
    (50) orExpression -> . orExpression OR andExpression
    (47) andExpression -> . equalityExpression
    (48) andExpression -> . andExpression AND equalityExpression
    (43) equalityExpression -> . relationalExpression
    (44) equalityExpression -> . equalityExpression eqop relationalExpression
    (37) relationalExpression -> . additiveExpression
    (38) relationalExpression -> . relationalExpression compop additiveExpression
    (33) additiveExpression -> . multiplicativeExpression
    (34) additiveExpression -> . additiveExpression addop multiplicativeExpression
    (29) multiplicativeExpression -> . unaryExpression
    (30) multiplicativeExpression -> . multiplicativeExpression multop unaryExpression
    (23) unaryExpression -> . unop unaryExpression
    (24) unaryExpression -> . postfixExpression
    (25) unop -> . PLUS
    (26) unop -> . MINUS
    (27) unop -> . EXCLAMATION
    (28) unop -> . TILDE
    (17) postfixExpression -> . constant
    (18) postfixExpression -> . identifier
    (19) postfixExpression -> . LPAREN expression RPAREN
    (21) postfixExpression -> . postfixExpression LBRACKET expression RBRACKET
    (22) postfixExpression -> . IDENT LPAREN expressionlist RPAREN
    (14) constant -> . NUMBER
    (15) constant -> . TRUE
    (16) constant -> . FALSE
    (20) identifier -> . IDENT

    PLUS            shift and go to state 59
    MINUS           shift and go to state 57
    EXCLAMATION     shift and go to state 64
    TILDE           shift and go to state 60
    LPAREN          shift and go to state 38
    IDENT           shift and go to state 56
    NUMBER          shift and go to state 30
    TRUE            shift and go to state 31
    FALSE           shift and go to state 42

    equalityExpression             shift and go to state 53
    additiveExpression             shift and go to state 61
    conditionalExpression          shift and go to state 62
    unaryExpression                shift and go to state 63
    multiplicativeExpression       shift and go to state 55
    orExpression                   shift and go to state 58
    relationalExpression           shift and go to state 65
    unop                           shift and go to state 54
    andExpression                  shift and go to state 66
    postfixExpression              shift and go to state 67
    constant                       shift and go to state 29
    identifier                     shift and go to state 44
    expression                     shift and go to state 125

state 112

    (71) iterationStatement -> FOR LPAREN assignmentStatement SEMICOLON . expression SEMICOLON assignmentStatement RPAREN statement
    (53) expression -> . conditionalExpression
    (51) conditionalExpression -> . orExpression
    (52) conditionalExpression -> . orExpression QUESTION expression COLON expression
    (49) orExpression -> . andExpression
    (50) orExpression -> . orExpression OR andExpression
    (47) andExpression -> . equalityExpression
    (48) andExpression -> . andExpression AND equalityExpression
    (43) equalityExpression -> . relationalExpression
    (44) equalityExpression -> . equalityExpression eqop relationalExpression
    (37) relationalExpression -> . additiveExpression
    (38) relationalExpression -> . relationalExpression compop additiveExpression
    (33) additiveExpression -> . multiplicativeExpression
    (34) additiveExpression -> . additiveExpression addop multiplicativeExpression
    (29) multiplicativeExpression -> . unaryExpression
    (30) multiplicativeExpression -> . multiplicativeExpression multop unaryExpression
    (23) unaryExpression -> . unop unaryExpression
    (24) unaryExpression -> . postfixExpression
    (25) unop -> . PLUS
    (26) unop -> . MINUS
    (27) unop -> . EXCLAMATION
    (28) unop -> . TILDE
    (17) postfixExpression -> . constant
    (18) postfixExpression -> . identifier
    (19) postfixExpression -> . LPAREN expression RPAREN
    (21) postfixExpression -> . postfixExpression LBRACKET expression RBRACKET
    (22) postfixExpression -> . IDENT LPAREN expressionlist RPAREN
    (14) constant -> . NUMBER
    (15) constant -> . TRUE
    (16) constant -> . FALSE
    (20) identifier -> . IDENT

    PLUS            shift and go to state 59
    MINUS           shift and go to state 57
    EXCLAMATION     shift and go to state 64
    TILDE           shift and go to state 60
    LPAREN          shift and go to state 38
    IDENT           shift and go to state 56
    NUMBER          shift and go to state 30
    TRUE            shift and go to state 31
    FALSE           shift and go to state 42

    equalityExpression             shift and go to state 53
    additiveExpression             shift and go to state 61
    conditionalExpression          shift and go to state 62
    unaryExpression                shift and go to state 63
    multiplicativeExpression       shift and go to state 55
    orExpression                   shift and go to state 58
    relationalExpression           shift and go to state 65
    unop                           shift and go to state 54
    andExpression                  shift and go to state 66
    postfixExpression              shift and go to state 67
    constant                       shift and go to state 29
    identifier                     shift and go to state 44
    expression                     shift and go to state 126

state 113

    (44) equalityExpression -> equalityExpression eqop relationalExpression .
    (38) relationalExpression -> relationalExpression . compop additiveExpression
    (39) compop -> . LT
    (40) compop -> . LEQ
    (41) compop -> . GT
    (42) compop -> . GEQ

    EQEQ            reduce using rule 44 (equalityExpression -> equalityExpression eqop relationalExpression .)
    NEQ             reduce using rule 44 (equalityExpression -> equalityExpression eqop relationalExpression .)
    AND             reduce using rule 44 (equalityExpression -> equalityExpression eqop relationalExpression .)
    QUESTION        reduce using rule 44 (equalityExpression -> equalityExpression eqop relationalExpression .)
    OR              reduce using rule 44 (equalityExpression -> equalityExpression eqop relationalExpression .)
    SEMICOLON       reduce using rule 44 (equalityExpression -> equalityExpression eqop relationalExpression .)
    RPAREN          reduce using rule 44 (equalityExpression -> equalityExpression eqop relationalExpression .)
    COMMA           reduce using rule 44 (equalityExpression -> equalityExpression eqop relationalExpression .)
    RBRACKET        reduce using rule 44 (equalityExpression -> equalityExpression eqop relationalExpression .)
    COLON           reduce using rule 44 (equalityExpression -> equalityExpression eqop relationalExpression .)
    LT              shift and go to state 98
    LEQ             shift and go to state 96
    GT              shift and go to state 95
    GEQ             shift and go to state 94

    compop                         shift and go to state 97

state 114

    (30) multiplicativeExpression -> multiplicativeExpression multop unaryExpression .

    TIMES           reduce using rule 30 (multiplicativeExpression -> multiplicativeExpression multop unaryExpression .)
    DIV             reduce using rule 30 (multiplicativeExpression -> multiplicativeExpression multop unaryExpression .)
    PLUS            reduce using rule 30 (multiplicativeExpression -> multiplicativeExpression multop unaryExpression .)
    MINUS           reduce using rule 30 (multiplicativeExpression -> multiplicativeExpression multop unaryExpression .)
    LT              reduce using rule 30 (multiplicativeExpression -> multiplicativeExpression multop unaryExpression .)
    LEQ             reduce using rule 30 (multiplicativeExpression -> multiplicativeExpression multop unaryExpression .)
    GT              reduce using rule 30 (multiplicativeExpression -> multiplicativeExpression multop unaryExpression .)
    GEQ             reduce using rule 30 (multiplicativeExpression -> multiplicativeExpression multop unaryExpression .)
    EQEQ            reduce using rule 30 (multiplicativeExpression -> multiplicativeExpression multop unaryExpression .)
    NEQ             reduce using rule 30 (multiplicativeExpression -> multiplicativeExpression multop unaryExpression .)
    AND             reduce using rule 30 (multiplicativeExpression -> multiplicativeExpression multop unaryExpression .)
    QUESTION        reduce using rule 30 (multiplicativeExpression -> multiplicativeExpression multop unaryExpression .)
    OR              reduce using rule 30 (multiplicativeExpression -> multiplicativeExpression multop unaryExpression .)
    RPAREN          reduce using rule 30 (multiplicativeExpression -> multiplicativeExpression multop unaryExpression .)
    COMMA           reduce using rule 30 (multiplicativeExpression -> multiplicativeExpression multop unaryExpression .)
    SEMICOLON       reduce using rule 30 (multiplicativeExpression -> multiplicativeExpression multop unaryExpression .)
    RBRACKET        reduce using rule 30 (multiplicativeExpression -> multiplicativeExpression multop unaryExpression .)
    COLON           reduce using rule 30 (multiplicativeExpression -> multiplicativeExpression multop unaryExpression .)


state 115

    (52) conditionalExpression -> orExpression QUESTION expression . COLON expression

    COLON           shift and go to state 127


state 116

    (50) orExpression -> orExpression OR andExpression .
    (48) andExpression -> andExpression . AND equalityExpression

    QUESTION        reduce using rule 50 (orExpression -> orExpression OR andExpression .)
    OR              reduce using rule 50 (orExpression -> orExpression OR andExpression .)
    RPAREN          reduce using rule 50 (orExpression -> orExpression OR andExpression .)
    COMMA           reduce using rule 50 (orExpression -> orExpression OR andExpression .)
    SEMICOLON       reduce using rule 50 (orExpression -> orExpression OR andExpression .)
    RBRACKET        reduce using rule 50 (orExpression -> orExpression OR andExpression .)
    COLON           reduce using rule 50 (orExpression -> orExpression OR andExpression .)
    AND             shift and go to state 99


state 117

    (34) additiveExpression -> additiveExpression addop multiplicativeExpression .
    (30) multiplicativeExpression -> multiplicativeExpression . multop unaryExpression
    (31) multop -> . TIMES
    (32) multop -> . DIV

    PLUS            reduce using rule 34 (additiveExpression -> additiveExpression addop multiplicativeExpression .)
    MINUS           reduce using rule 34 (additiveExpression -> additiveExpression addop multiplicativeExpression .)
    LT              reduce using rule 34 (additiveExpression -> additiveExpression addop multiplicativeExpression .)
    LEQ             reduce using rule 34 (additiveExpression -> additiveExpression addop multiplicativeExpression .)
    GT              reduce using rule 34 (additiveExpression -> additiveExpression addop multiplicativeExpression .)
    GEQ             reduce using rule 34 (additiveExpression -> additiveExpression addop multiplicativeExpression .)
    EQEQ            reduce using rule 34 (additiveExpression -> additiveExpression addop multiplicativeExpression .)
    NEQ             reduce using rule 34 (additiveExpression -> additiveExpression addop multiplicativeExpression .)
    AND             reduce using rule 34 (additiveExpression -> additiveExpression addop multiplicativeExpression .)
    QUESTION        reduce using rule 34 (additiveExpression -> additiveExpression addop multiplicativeExpression .)
    OR              reduce using rule 34 (additiveExpression -> additiveExpression addop multiplicativeExpression .)
    SEMICOLON       reduce using rule 34 (additiveExpression -> additiveExpression addop multiplicativeExpression .)
    RPAREN          reduce using rule 34 (additiveExpression -> additiveExpression addop multiplicativeExpression .)
    COMMA           reduce using rule 34 (additiveExpression -> additiveExpression addop multiplicativeExpression .)
    RBRACKET        reduce using rule 34 (additiveExpression -> additiveExpression addop multiplicativeExpression .)
    COLON           reduce using rule 34 (additiveExpression -> additiveExpression addop multiplicativeExpression .)
    TIMES           shift and go to state 88
    DIV             shift and go to state 86

    multop                         shift and go to state 87

state 118

    (38) relationalExpression -> relationalExpression compop additiveExpression .
    (34) additiveExpression -> additiveExpression . addop multiplicativeExpression
    (35) addop -> . PLUS
    (36) addop -> . MINUS

    LT              reduce using rule 38 (relationalExpression -> relationalExpression compop additiveExpression .)
    LEQ             reduce using rule 38 (relationalExpression -> relationalExpression compop additiveExpression .)
    GT              reduce using rule 38 (relationalExpression -> relationalExpression compop additiveExpression .)
    GEQ             reduce using rule 38 (relationalExpression -> relationalExpression compop additiveExpression .)
    EQEQ            reduce using rule 38 (relationalExpression -> relationalExpression compop additiveExpression .)
    NEQ             reduce using rule 38 (relationalExpression -> relationalExpression compop additiveExpression .)
    AND             reduce using rule 38 (relationalExpression -> relationalExpression compop additiveExpression .)
    QUESTION        reduce using rule 38 (relationalExpression -> relationalExpression compop additiveExpression .)
    OR              reduce using rule 38 (relationalExpression -> relationalExpression compop additiveExpression .)
    RPAREN          reduce using rule 38 (relationalExpression -> relationalExpression compop additiveExpression .)
    COMMA           reduce using rule 38 (relationalExpression -> relationalExpression compop additiveExpression .)
    SEMICOLON       reduce using rule 38 (relationalExpression -> relationalExpression compop additiveExpression .)
    RBRACKET        reduce using rule 38 (relationalExpression -> relationalExpression compop additiveExpression .)
    COLON           reduce using rule 38 (relationalExpression -> relationalExpression compop additiveExpression .)
    PLUS            shift and go to state 92
    MINUS           shift and go to state 93

    addop                          shift and go to state 91

state 119

    (48) andExpression -> andExpression AND equalityExpression .
    (44) equalityExpression -> equalityExpression . eqop relationalExpression
    (45) eqop -> . EQEQ
    (46) eqop -> . NEQ

    AND             reduce using rule 48 (andExpression -> andExpression AND equalityExpression .)
    QUESTION        reduce using rule 48 (andExpression -> andExpression AND equalityExpression .)
    OR              reduce using rule 48 (andExpression -> andExpression AND equalityExpression .)
    RPAREN          reduce using rule 48 (andExpression -> andExpression AND equalityExpression .)
    COMMA           reduce using rule 48 (andExpression -> andExpression AND equalityExpression .)
    SEMICOLON       reduce using rule 48 (andExpression -> andExpression AND equalityExpression .)
    RBRACKET        reduce using rule 48 (andExpression -> andExpression AND equalityExpression .)
    COLON           reduce using rule 48 (andExpression -> andExpression AND equalityExpression .)
    EQEQ            shift and go to state 82
    NEQ             shift and go to state 84

    eqop                           shift and go to state 83

state 120

    (69) selectionStatement -> IF LPAREN expression RPAREN . statement ELSE statement
    (70) selectionStatement -> IF LPAREN expression RPAREN . statement
    (64) statement -> . assignmentStatement SEMICOLON
    (65) statement -> . iterationStatement
    (66) statement -> . selectionStatement
    (67) statement -> . block
    (68) statement -> . error SEMICOLON
    (59) assignmentStatement -> . postfixExpression EQ expression
    (60) assignmentStatement -> . IDENT PLUS PLUS
    (61) assignmentStatement -> . IDENT MINUS MINUS
    (62) assignmentStatement -> . postfixExpression EQ error
    (63) assignmentStatement -> . error EQ expression
    (71) iterationStatement -> . FOR LPAREN assignmentStatement SEMICOLON expression SEMICOLON assignmentStatement RPAREN statement
    (69) selectionStatement -> . IF LPAREN expression RPAREN statement ELSE statement
    (70) selectionStatement -> . IF LPAREN expression RPAREN statement
    (72) block -> . LBRACE statementlist RBRACE
    (17) postfixExpression -> . constant
    (18) postfixExpression -> . identifier
    (19) postfixExpression -> . LPAREN expression RPAREN
    (21) postfixExpression -> . postfixExpression LBRACKET expression RBRACKET
    (22) postfixExpression -> . IDENT LPAREN expressionlist RPAREN
    (14) constant -> . NUMBER
    (15) constant -> . TRUE
    (16) constant -> . FALSE
    (20) identifier -> . IDENT

    error           shift and go to state 43
    IDENT           shift and go to state 35
    FOR             shift and go to state 37
    IF              shift and go to state 40
    LBRACE          shift and go to state 21
    LPAREN          shift and go to state 38
    NUMBER          shift and go to state 30
    TRUE            shift and go to state 31
    FALSE           shift and go to state 42

    postfixExpression              shift and go to state 41
    constant                       shift and go to state 29
    block                          shift and go to state 45
    statement                      shift and go to state 128
    identifier                     shift and go to state 44
    assignmentStatement            shift and go to state 34
    iterationStatement             shift and go to state 39
    selectionStatement             shift and go to state 32

state 121

    (21) postfixExpression -> postfixExpression LBRACKET expression RBRACKET .

    LBRACKET        reduce using rule 21 (postfixExpression -> postfixExpression LBRACKET expression RBRACKET .)
    TIMES           reduce using rule 21 (postfixExpression -> postfixExpression LBRACKET expression RBRACKET .)
    DIV             reduce using rule 21 (postfixExpression -> postfixExpression LBRACKET expression RBRACKET .)
    PLUS            reduce using rule 21 (postfixExpression -> postfixExpression LBRACKET expression RBRACKET .)
    MINUS           reduce using rule 21 (postfixExpression -> postfixExpression LBRACKET expression RBRACKET .)
    LT              reduce using rule 21 (postfixExpression -> postfixExpression LBRACKET expression RBRACKET .)
    LEQ             reduce using rule 21 (postfixExpression -> postfixExpression LBRACKET expression RBRACKET .)
    GT              reduce using rule 21 (postfixExpression -> postfixExpression LBRACKET expression RBRACKET .)
    GEQ             reduce using rule 21 (postfixExpression -> postfixExpression LBRACKET expression RBRACKET .)
    EQEQ            reduce using rule 21 (postfixExpression -> postfixExpression LBRACKET expression RBRACKET .)
    NEQ             reduce using rule 21 (postfixExpression -> postfixExpression LBRACKET expression RBRACKET .)
    AND             reduce using rule 21 (postfixExpression -> postfixExpression LBRACKET expression RBRACKET .)
    QUESTION        reduce using rule 21 (postfixExpression -> postfixExpression LBRACKET expression RBRACKET .)
    OR              reduce using rule 21 (postfixExpression -> postfixExpression LBRACKET expression RBRACKET .)
    SEMICOLON       reduce using rule 21 (postfixExpression -> postfixExpression LBRACKET expression RBRACKET .)
    RPAREN          reduce using rule 21 (postfixExpression -> postfixExpression LBRACKET expression RBRACKET .)
    COMMA           reduce using rule 21 (postfixExpression -> postfixExpression LBRACKET expression RBRACKET .)
    RBRACKET        reduce using rule 21 (postfixExpression -> postfixExpression LBRACKET expression RBRACKET .)
    COLON           reduce using rule 21 (postfixExpression -> postfixExpression LBRACKET expression RBRACKET .)
    EQ              reduce using rule 21 (postfixExpression -> postfixExpression LBRACKET expression RBRACKET .)


state 122

    (5) sequentialspec -> SEQUENTIAL LPAREN arglist RPAREN RETURNS LPAREN identlist RPAREN . LOCALS LPAREN arglist RPAREN block

    LOCALS          shift and go to state 129


state 123

    (12) identlist -> identifier COMMA . identlist
    (11) identlist -> . identifier
    (12) identlist -> . identifier COMMA identlist
    (13) identlist -> .
    (20) identifier -> . IDENT

    RPAREN          reduce using rule 13 (identlist -> .)
    IDENT           shift and go to state 108

    identifier                     shift and go to state 107
    identlist                      shift and go to state 130

state 124

    (2) joinspec -> JOIN LPAREN arglist SEPARE arglist RPAREN RETURNS LPAREN identlist RPAREN . LOCALS LPAREN arglist RPAREN block
    (4) joinspec -> JOIN LPAREN arglist SEPARE arglist RPAREN RETURNS LPAREN identlist RPAREN . LOCALS LPAREN arglist RPAREN error

    LOCALS          shift and go to state 131


state 125

    (55) expressionlist -> expressionlist COMMA expression .

    RPAREN          reduce using rule 55 (expressionlist -> expressionlist COMMA expression .)
    COMMA           reduce using rule 55 (expressionlist -> expressionlist COMMA expression .)


state 126

    (71) iterationStatement -> FOR LPAREN assignmentStatement SEMICOLON expression . SEMICOLON assignmentStatement RPAREN statement

    SEMICOLON       shift and go to state 132


state 127

    (52) conditionalExpression -> orExpression QUESTION expression COLON . expression
    (53) expression -> . conditionalExpression
    (51) conditionalExpression -> . orExpression
    (52) conditionalExpression -> . orExpression QUESTION expression COLON expression
    (49) orExpression -> . andExpression
    (50) orExpression -> . orExpression OR andExpression
    (47) andExpression -> . equalityExpression
    (48) andExpression -> . andExpression AND equalityExpression
    (43) equalityExpression -> . relationalExpression
    (44) equalityExpression -> . equalityExpression eqop relationalExpression
    (37) relationalExpression -> . additiveExpression
    (38) relationalExpression -> . relationalExpression compop additiveExpression
    (33) additiveExpression -> . multiplicativeExpression
    (34) additiveExpression -> . additiveExpression addop multiplicativeExpression
    (29) multiplicativeExpression -> . unaryExpression
    (30) multiplicativeExpression -> . multiplicativeExpression multop unaryExpression
    (23) unaryExpression -> . unop unaryExpression
    (24) unaryExpression -> . postfixExpression
    (25) unop -> . PLUS
    (26) unop -> . MINUS
    (27) unop -> . EXCLAMATION
    (28) unop -> . TILDE
    (17) postfixExpression -> . constant
    (18) postfixExpression -> . identifier
    (19) postfixExpression -> . LPAREN expression RPAREN
    (21) postfixExpression -> . postfixExpression LBRACKET expression RBRACKET
    (22) postfixExpression -> . IDENT LPAREN expressionlist RPAREN
    (14) constant -> . NUMBER
    (15) constant -> . TRUE
    (16) constant -> . FALSE
    (20) identifier -> . IDENT

    PLUS            shift and go to state 59
    MINUS           shift and go to state 57
    EXCLAMATION     shift and go to state 64
    TILDE           shift and go to state 60
    LPAREN          shift and go to state 38
    IDENT           shift and go to state 56
    NUMBER          shift and go to state 30
    TRUE            shift and go to state 31
    FALSE           shift and go to state 42

    equalityExpression             shift and go to state 53
    additiveExpression             shift and go to state 61
    conditionalExpression          shift and go to state 62
    unaryExpression                shift and go to state 63
    multiplicativeExpression       shift and go to state 55
    orExpression                   shift and go to state 58
    relationalExpression           shift and go to state 65
    unop                           shift and go to state 54
    andExpression                  shift and go to state 66
    postfixExpression              shift and go to state 67
    constant                       shift and go to state 29
    identifier                     shift and go to state 44
    expression                     shift and go to state 133

state 128

    (69) selectionStatement -> IF LPAREN expression RPAREN statement . ELSE statement
    (70) selectionStatement -> IF LPAREN expression RPAREN statement .

    ELSE            shift and go to state 134
    RBRACE          reduce using rule 70 (selectionStatement -> IF LPAREN expression RPAREN statement .)
    error           reduce using rule 70 (selectionStatement -> IF LPAREN expression RPAREN statement .)
    IDENT           reduce using rule 70 (selectionStatement -> IF LPAREN expression RPAREN statement .)
    FOR             reduce using rule 70 (selectionStatement -> IF LPAREN expression RPAREN statement .)
    IF              reduce using rule 70 (selectionStatement -> IF LPAREN expression RPAREN statement .)
    LBRACE          reduce using rule 70 (selectionStatement -> IF LPAREN expression RPAREN statement .)
    LPAREN          reduce using rule 70 (selectionStatement -> IF LPAREN expression RPAREN statement .)
    NUMBER          reduce using rule 70 (selectionStatement -> IF LPAREN expression RPAREN statement .)
    TRUE            reduce using rule 70 (selectionStatement -> IF LPAREN expression RPAREN statement .)
    FALSE           reduce using rule 70 (selectionStatement -> IF LPAREN expression RPAREN statement .)

  ! ELSE            [ reduce using rule 70 (selectionStatement -> IF LPAREN expression RPAREN statement .) ]


state 129

    (5) sequentialspec -> SEQUENTIAL LPAREN arglist RPAREN RETURNS LPAREN identlist RPAREN LOCALS . LPAREN arglist RPAREN block

    LPAREN          shift and go to state 135


state 130

    (12) identlist -> identifier COMMA identlist .

    RPAREN          reduce using rule 12 (identlist -> identifier COMMA identlist .)


state 131

    (2) joinspec -> JOIN LPAREN arglist SEPARE arglist RPAREN RETURNS LPAREN identlist RPAREN LOCALS . LPAREN arglist RPAREN block
    (4) joinspec -> JOIN LPAREN arglist SEPARE arglist RPAREN RETURNS LPAREN identlist RPAREN LOCALS . LPAREN arglist RPAREN error

    LPAREN          shift and go to state 136


state 132

    (71) iterationStatement -> FOR LPAREN assignmentStatement SEMICOLON expression SEMICOLON . assignmentStatement RPAREN statement
    (59) assignmentStatement -> . postfixExpression EQ expression
    (60) assignmentStatement -> . IDENT PLUS PLUS
    (61) assignmentStatement -> . IDENT MINUS MINUS
    (62) assignmentStatement -> . postfixExpression EQ error
    (63) assignmentStatement -> . error EQ expression
    (17) postfixExpression -> . constant
    (18) postfixExpression -> . identifier
    (19) postfixExpression -> . LPAREN expression RPAREN
    (21) postfixExpression -> . postfixExpression LBRACKET expression RBRACKET
    (22) postfixExpression -> . IDENT LPAREN expressionlist RPAREN
    (14) constant -> . NUMBER
    (15) constant -> . TRUE
    (16) constant -> . FALSE
    (20) identifier -> . IDENT

    IDENT           shift and go to state 35
    error           shift and go to state 80
    LPAREN          shift and go to state 38
    NUMBER          shift and go to state 30
    TRUE            shift and go to state 31
    FALSE           shift and go to state 42

    postfixExpression              shift and go to state 41
    constant                       shift and go to state 29
    identifier                     shift and go to state 44
    assignmentStatement            shift and go to state 137

state 133

    (52) conditionalExpression -> orExpression QUESTION expression COLON expression .

    RBRACKET        reduce using rule 52 (conditionalExpression -> orExpression QUESTION expression COLON expression .)
    SEMICOLON       reduce using rule 52 (conditionalExpression -> orExpression QUESTION expression COLON expression .)
    RPAREN          reduce using rule 52 (conditionalExpression -> orExpression QUESTION expression COLON expression .)
    COMMA           reduce using rule 52 (conditionalExpression -> orExpression QUESTION expression COLON expression .)
    COLON           reduce using rule 52 (conditionalExpression -> orExpression QUESTION expression COLON expression .)


state 134

    (69) selectionStatement -> IF LPAREN expression RPAREN statement ELSE . statement
    (64) statement -> . assignmentStatement SEMICOLON
    (65) statement -> . iterationStatement
    (66) statement -> . selectionStatement
    (67) statement -> . block
    (68) statement -> . error SEMICOLON
    (59) assignmentStatement -> . postfixExpression EQ expression
    (60) assignmentStatement -> . IDENT PLUS PLUS
    (61) assignmentStatement -> . IDENT MINUS MINUS
    (62) assignmentStatement -> . postfixExpression EQ error
    (63) assignmentStatement -> . error EQ expression
    (71) iterationStatement -> . FOR LPAREN assignmentStatement SEMICOLON expression SEMICOLON assignmentStatement RPAREN statement
    (69) selectionStatement -> . IF LPAREN expression RPAREN statement ELSE statement
    (70) selectionStatement -> . IF LPAREN expression RPAREN statement
    (72) block -> . LBRACE statementlist RBRACE
    (17) postfixExpression -> . constant
    (18) postfixExpression -> . identifier
    (19) postfixExpression -> . LPAREN expression RPAREN
    (21) postfixExpression -> . postfixExpression LBRACKET expression RBRACKET
    (22) postfixExpression -> . IDENT LPAREN expressionlist RPAREN
    (14) constant -> . NUMBER
    (15) constant -> . TRUE
    (16) constant -> . FALSE
    (20) identifier -> . IDENT

    error           shift and go to state 43
    IDENT           shift and go to state 35
    FOR             shift and go to state 37
    IF              shift and go to state 40
    LBRACE          shift and go to state 21
    LPAREN          shift and go to state 38
    NUMBER          shift and go to state 30
    TRUE            shift and go to state 31
    FALSE           shift and go to state 42

    postfixExpression              shift and go to state 41
    constant                       shift and go to state 29
    block                          shift and go to state 45
    statement                      shift and go to state 138
    identifier                     shift and go to state 44
    assignmentStatement            shift and go to state 34
    iterationStatement             shift and go to state 39
    selectionStatement             shift and go to state 32

state 135

    (5) sequentialspec -> SEQUENTIAL LPAREN arglist RPAREN RETURNS LPAREN identlist RPAREN LOCALS LPAREN . arglist RPAREN block
    (6) arglist -> . arglist COMMA arg
    (7) arglist -> . arg
    (8) arglist -> .
    (9) arg -> . type IDENT
    (10) arg -> . error
    (73) type -> . INT
    (74) type -> . FLOAT
    (75) type -> . BOOL
    (76) type -> . type TIMES

    RPAREN          reduce using rule 8 (arglist -> .)
    COMMA           reduce using rule 8 (arglist -> .)
    error           shift and go to state 12
    INT             shift and go to state 8
    FLOAT           shift and go to state 11
    BOOL            shift and go to state 14

    arglist                        shift and go to state 139
    type                           shift and go to state 9
    arg                            shift and go to state 10

state 136

    (2) joinspec -> JOIN LPAREN arglist SEPARE arglist RPAREN RETURNS LPAREN identlist RPAREN LOCALS LPAREN . arglist RPAREN block
    (4) joinspec -> JOIN LPAREN arglist SEPARE arglist RPAREN RETURNS LPAREN identlist RPAREN LOCALS LPAREN . arglist RPAREN error
    (6) arglist -> . arglist COMMA arg
    (7) arglist -> . arg
    (8) arglist -> .
    (9) arg -> . type IDENT
    (10) arg -> . error
    (73) type -> . INT
    (74) type -> . FLOAT
    (75) type -> . BOOL
    (76) type -> . type TIMES

    RPAREN          reduce using rule 8 (arglist -> .)
    COMMA           reduce using rule 8 (arglist -> .)
    error           shift and go to state 12
    INT             shift and go to state 8
    FLOAT           shift and go to state 11
    BOOL            shift and go to state 14

    arglist                        shift and go to state 140
    type                           shift and go to state 9
    arg                            shift and go to state 10

state 137

    (71) iterationStatement -> FOR LPAREN assignmentStatement SEMICOLON expression SEMICOLON assignmentStatement . RPAREN statement

    RPAREN          shift and go to state 141


state 138

    (69) selectionStatement -> IF LPAREN expression RPAREN statement ELSE statement .

    RBRACE          reduce using rule 69 (selectionStatement -> IF LPAREN expression RPAREN statement ELSE statement .)
    error           reduce using rule 69 (selectionStatement -> IF LPAREN expression RPAREN statement ELSE statement .)
    IDENT           reduce using rule 69 (selectionStatement -> IF LPAREN expression RPAREN statement ELSE statement .)
    FOR             reduce using rule 69 (selectionStatement -> IF LPAREN expression RPAREN statement ELSE statement .)
    IF              reduce using rule 69 (selectionStatement -> IF LPAREN expression RPAREN statement ELSE statement .)
    LBRACE          reduce using rule 69 (selectionStatement -> IF LPAREN expression RPAREN statement ELSE statement .)
    LPAREN          reduce using rule 69 (selectionStatement -> IF LPAREN expression RPAREN statement ELSE statement .)
    NUMBER          reduce using rule 69 (selectionStatement -> IF LPAREN expression RPAREN statement ELSE statement .)
    TRUE            reduce using rule 69 (selectionStatement -> IF LPAREN expression RPAREN statement ELSE statement .)
    FALSE           reduce using rule 69 (selectionStatement -> IF LPAREN expression RPAREN statement ELSE statement .)
    ELSE            reduce using rule 69 (selectionStatement -> IF LPAREN expression RPAREN statement ELSE statement .)


state 139

    (5) sequentialspec -> SEQUENTIAL LPAREN arglist RPAREN RETURNS LPAREN identlist RPAREN LOCALS LPAREN arglist . RPAREN block
    (6) arglist -> arglist . COMMA arg

    RPAREN          shift and go to state 142
    COMMA           shift and go to state 19


state 140

    (2) joinspec -> JOIN LPAREN arglist SEPARE arglist RPAREN RETURNS LPAREN identlist RPAREN LOCALS LPAREN arglist . RPAREN block
    (4) joinspec -> JOIN LPAREN arglist SEPARE arglist RPAREN RETURNS LPAREN identlist RPAREN LOCALS LPAREN arglist . RPAREN error
    (6) arglist -> arglist . COMMA arg

    RPAREN          shift and go to state 143
    COMMA           shift and go to state 19


state 141

    (71) iterationStatement -> FOR LPAREN assignmentStatement SEMICOLON expression SEMICOLON assignmentStatement RPAREN . statement
    (64) statement -> . assignmentStatement SEMICOLON
    (65) statement -> . iterationStatement
    (66) statement -> . selectionStatement
    (67) statement -> . block
    (68) statement -> . error SEMICOLON
    (59) assignmentStatement -> . postfixExpression EQ expression
    (60) assignmentStatement -> . IDENT PLUS PLUS
    (61) assignmentStatement -> . IDENT MINUS MINUS
    (62) assignmentStatement -> . postfixExpression EQ error
    (63) assignmentStatement -> . error EQ expression
    (71) iterationStatement -> . FOR LPAREN assignmentStatement SEMICOLON expression SEMICOLON assignmentStatement RPAREN statement
    (69) selectionStatement -> . IF LPAREN expression RPAREN statement ELSE statement
    (70) selectionStatement -> . IF LPAREN expression RPAREN statement
    (72) block -> . LBRACE statementlist RBRACE
    (17) postfixExpression -> . constant
    (18) postfixExpression -> . identifier
    (19) postfixExpression -> . LPAREN expression RPAREN
    (21) postfixExpression -> . postfixExpression LBRACKET expression RBRACKET
    (22) postfixExpression -> . IDENT LPAREN expressionlist RPAREN
    (14) constant -> . NUMBER
    (15) constant -> . TRUE
    (16) constant -> . FALSE
    (20) identifier -> . IDENT

    error           shift and go to state 43
    IDENT           shift and go to state 35
    FOR             shift and go to state 37
    IF              shift and go to state 40
    LBRACE          shift and go to state 21
    LPAREN          shift and go to state 38
    NUMBER          shift and go to state 30
    TRUE            shift and go to state 31
    FALSE           shift and go to state 42

    postfixExpression              shift and go to state 41
    constant                       shift and go to state 29
    block                          shift and go to state 45
    statement                      shift and go to state 144
    identifier                     shift and go to state 44
    assignmentStatement            shift and go to state 34
    iterationStatement             shift and go to state 39
    selectionStatement             shift and go to state 32

state 142

    (5) sequentialspec -> SEQUENTIAL LPAREN arglist RPAREN RETURNS LPAREN identlist RPAREN LOCALS LPAREN arglist RPAREN . block
    (72) block -> . LBRACE statementlist RBRACE

    LBRACE          shift and go to state 21

    block                          shift and go to state 145

state 143

    (2) joinspec -> JOIN LPAREN arglist SEPARE arglist RPAREN RETURNS LPAREN identlist RPAREN LOCALS LPAREN arglist RPAREN . block
    (4) joinspec -> JOIN LPAREN arglist SEPARE arglist RPAREN RETURNS LPAREN identlist RPAREN LOCALS LPAREN arglist RPAREN . error
    (72) block -> . LBRACE statementlist RBRACE

    error           shift and go to state 147
    LBRACE          shift and go to state 21

    block                          shift and go to state 146

state 144

    (71) iterationStatement -> FOR LPAREN assignmentStatement SEMICOLON expression SEMICOLON assignmentStatement RPAREN statement .

    ELSE            reduce using rule 71 (iterationStatement -> FOR LPAREN assignmentStatement SEMICOLON expression SEMICOLON assignmentStatement RPAREN statement .)
    RBRACE          reduce using rule 71 (iterationStatement -> FOR LPAREN assignmentStatement SEMICOLON expression SEMICOLON assignmentStatement RPAREN statement .)
    error           reduce using rule 71 (iterationStatement -> FOR LPAREN assignmentStatement SEMICOLON expression SEMICOLON assignmentStatement RPAREN statement .)
    IDENT           reduce using rule 71 (iterationStatement -> FOR LPAREN assignmentStatement SEMICOLON expression SEMICOLON assignmentStatement RPAREN statement .)
    FOR             reduce using rule 71 (iterationStatement -> FOR LPAREN assignmentStatement SEMICOLON expression SEMICOLON assignmentStatement RPAREN statement .)
    IF              reduce using rule 71 (iterationStatement -> FOR LPAREN assignmentStatement SEMICOLON expression SEMICOLON assignmentStatement RPAREN statement .)
    LBRACE          reduce using rule 71 (iterationStatement -> FOR LPAREN assignmentStatement SEMICOLON expression SEMICOLON assignmentStatement RPAREN statement .)
    LPAREN          reduce using rule 71 (iterationStatement -> FOR LPAREN assignmentStatement SEMICOLON expression SEMICOLON assignmentStatement RPAREN statement .)
    NUMBER          reduce using rule 71 (iterationStatement -> FOR LPAREN assignmentStatement SEMICOLON expression SEMICOLON assignmentStatement RPAREN statement .)
    TRUE            reduce using rule 71 (iterationStatement -> FOR LPAREN assignmentStatement SEMICOLON expression SEMICOLON assignmentStatement RPAREN statement .)
    FALSE           reduce using rule 71 (iterationStatement -> FOR LPAREN assignmentStatement SEMICOLON expression SEMICOLON assignmentStatement RPAREN statement .)


state 145

    (5) sequentialspec -> SEQUENTIAL LPAREN arglist RPAREN RETURNS LPAREN identlist RPAREN LOCALS LPAREN arglist RPAREN block .

    $end            reduce using rule 5 (sequentialspec -> SEQUENTIAL LPAREN arglist RPAREN RETURNS LPAREN identlist RPAREN LOCALS LPAREN arglist RPAREN block .)


state 146

    (2) joinspec -> JOIN LPAREN arglist SEPARE arglist RPAREN RETURNS LPAREN identlist RPAREN LOCALS LPAREN arglist RPAREN block .

    SEQUENTIAL      reduce using rule 2 (joinspec -> JOIN LPAREN arglist SEPARE arglist RPAREN RETURNS LPAREN identlist RPAREN LOCALS LPAREN arglist RPAREN block .)


state 147

    (4) joinspec -> JOIN LPAREN arglist SEPARE arglist RPAREN RETURNS LPAREN identlist RPAREN LOCALS LPAREN arglist RPAREN error .

    SEQUENTIAL      reduce using rule 4 (joinspec -> JOIN LPAREN arglist SEPARE arglist RPAREN RETURNS LPAREN identlist RPAREN LOCALS LPAREN arglist RPAREN error .)

