Created by PLY version 3.10 (http://www.dabeaz.com/ply)

Grammar

Rule 0     S' -> program
Rule 1     program -> joinspec sequentialspec
Rule 2     joinspec -> JOIN LPAREN arglist SEPARE arglist RPAREN RETURNS LPAREN identlist RPAREN LOCALS LPAREN arglist RPAREN block
Rule 3     joinspec -> JOIN error RPAREN block
Rule 4     joinspec -> JOIN LPAREN arglist SEPARE arglist RPAREN RETURNS LPAREN identlist RPAREN LOCALS LPAREN arglist RPAREN error
Rule 5     sequentialspec -> SEQUENTIAL LPAREN arglist RPAREN RETURNS LPAREN identlist RPAREN LOCALS LPAREN arglist RPAREN block
Rule 6     arglist -> arglist COMMA arg
Rule 7     arglist -> arg
Rule 8     arglist -> <empty>
Rule 9     arg -> type IDENT
Rule 10    identlist -> IDENT
Rule 11    identlist -> IDENT COMMA identlist
Rule 12    identlist -> <empty>
Rule 13    constant -> NUMBER
Rule 14    constant -> TRUE
Rule 15    constant -> FALSE
Rule 16    postfixExpression -> constant
Rule 17    postfixExpression -> IDENT
Rule 18    postfixExpression -> LPAREN expression RPAREN
Rule 19    postfixExpression -> postfixExpression LBRACKET expression RBRACKET
Rule 20    postfixExpression -> IDENT LPAREN expressionlist RPAREN
Rule 21    unaryExpression -> unop unaryExpression
Rule 22    unaryExpression -> postfixExpression
Rule 23    unop -> PLUS
Rule 24    unop -> MINUS
Rule 25    unop -> EXCLAMATION
Rule 26    unop -> TILDE
Rule 27    multiplicativeExpression -> unaryExpression
Rule 28    multiplicativeExpression -> multiplicativeExpression multop unaryExpression
Rule 29    multop -> TIMES
Rule 30    multop -> DIV
Rule 31    additiveExpression -> unaryExpression
Rule 32    additiveExpression -> additiveExpression addop multiplicativeExpression
Rule 33    addop -> PLUS
Rule 34    addop -> MINUS
Rule 35    relationalExpression -> additiveExpression
Rule 36    relationalExpression -> relationalExpression compop additiveExpression
Rule 37    compop -> LT
Rule 38    compop -> LEQ
Rule 39    compop -> GT
Rule 40    compop -> GEQ
Rule 41    equalityExpression -> relationalExpression
Rule 42    equalityExpression -> equalityExpression eqop relationalExpression
Rule 43    eqop -> EQEQ
Rule 44    eqop -> NEQ
Rule 45    andExpression -> equalityExpression
Rule 46    andExpression -> andExpression AND equalityExpression
Rule 47    orExpression -> andExpression
Rule 48    orExpression -> orExpression OR andExpression
Rule 49    conditionalExpression -> orExpression
Rule 50    conditionalExpression -> orExpression QUESTION expression COLON expression
Rule 51    expression -> conditionalExpression
Rule 52    expressionlist -> expression
Rule 53    expressionlist -> expressionlist COMMA expression
Rule 54    expressionlist -> <empty>
Rule 55    statementlist -> statementlist statement
Rule 56    statementlist -> <empty>
Rule 57    assignmentStatement -> postfixExpression EQ expression
Rule 58    assignmentStatement -> postfixExpression EQ error
Rule 59    assignmentStatement -> error EQ expression
Rule 60    statement -> assignmentStatement SEMICOLON
Rule 61    statement -> iterationStatement
Rule 62    statement -> selectionStatement
Rule 63    statement -> block
Rule 64    statement -> error SEMICOLON
Rule 65    selectionStatement -> IF LPAREN expression RPAREN statement ELSE statement
Rule 66    selectionStatement -> IF LPAREN expression RPAREN statement
Rule 67    iterationStatement -> FOR LPAREN assignmentStatement SEMICOLON expression SEMICOLON assignmentStatement RPAREN statement
Rule 68    block -> LBRACE statementlist RBRACE
Rule 69    block -> LBRACE error RBRACE
Rule 70    type -> INT
Rule 71    type -> FLOAT
Rule 72    type -> BOOL
Rule 73    type -> type TIMES

Terminals, with rules where they appear

AND                  : 46
BOOL                 : 72
COLON                : 50
COMMA                : 6 11 53
DIV                  : 30
ELSE                 : 65
EQ                   : 57 58 59
EQEQ                 : 43
EXCLAMATION          : 25
FALSE                : 15
FLOAT                : 71
FOR                  : 67
GEQ                  : 40
GT                   : 39
IDENT                : 9 10 11 17 20
IF                   : 65 66
INT                  : 70
JOIN                 : 2 3 4
LBRACE               : 68 69
LBRACKET             : 19
LEQ                  : 38
LOCALS               : 2 4 5
LPAREN               : 2 2 2 4 4 4 5 5 5 18 20 65 66 67
LT                   : 37
MINUS                : 24 34
NEQ                  : 44
NUMBER               : 13
OR                   : 48
PLUS                 : 23 33
QUESTION             : 50
RBRACE               : 68 69
RBRACKET             : 19
RETURNS              : 2 4 5
RPAREN               : 2 2 2 3 4 4 4 5 5 5 18 20 65 66 67
SEMICOLON            : 60 64 67 67
SEPARE               : 2 4
SEQUENTIAL           : 5
TILDE                : 26
TIMES                : 29 73
TRUE                 : 14
error                : 3 4 58 59 64 69

Nonterminals, with rules where they appear

additiveExpression   : 32 35 36
addop                : 32
andExpression        : 46 47 48
arg                  : 6 7
arglist              : 2 2 2 4 4 4 5 5 6
assignmentStatement  : 60 67 67
block                : 2 3 5 63
compop               : 36
conditionalExpression : 51
constant             : 16
eqop                 : 42
equalityExpression   : 42 45 46
expression           : 18 19 50 50 52 53 57 59 65 66 67
expressionlist       : 20 53
identlist            : 2 4 5 11
iterationStatement   : 61
joinspec             : 1
multiplicativeExpression : 28 32
multop               : 28
orExpression         : 48 49 50
postfixExpression    : 19 22 57 58
program              : 0
relationalExpression : 36 41 42
selectionStatement   : 62
sequentialspec       : 1
statement            : 55 65 65 66 67
statementlist        : 55 68
type                 : 9 73
unaryExpression      : 21 27 28 31
unop                 : 21

Parsing method: LALR

state 0

    (0) S' -> . program
    (1) program -> . joinspec sequentialspec
    (2) joinspec -> . JOIN LPAREN arglist SEPARE arglist RPAREN RETURNS LPAREN identlist RPAREN LOCALS LPAREN arglist RPAREN block
    (3) joinspec -> . JOIN error RPAREN block
    (4) joinspec -> . JOIN LPAREN arglist SEPARE arglist RPAREN RETURNS LPAREN identlist RPAREN LOCALS LPAREN arglist RPAREN error

    JOIN            shift and go to state 1

    joinspec                       shift and go to state 2
    program                        shift and go to state 3

state 1

    (2) joinspec -> JOIN . LPAREN arglist SEPARE arglist RPAREN RETURNS LPAREN identlist RPAREN LOCALS LPAREN arglist RPAREN block
    (3) joinspec -> JOIN . error RPAREN block
    (4) joinspec -> JOIN . LPAREN arglist SEPARE arglist RPAREN RETURNS LPAREN identlist RPAREN LOCALS LPAREN arglist RPAREN error

    LPAREN          shift and go to state 4
    error           shift and go to state 5


state 2

    (1) program -> joinspec . sequentialspec
    (5) sequentialspec -> . SEQUENTIAL LPAREN arglist RPAREN RETURNS LPAREN identlist RPAREN LOCALS LPAREN arglist RPAREN block

    SEQUENTIAL      shift and go to state 7

    sequentialspec                 shift and go to state 6

state 3

    (0) S' -> program .



state 4

    (2) joinspec -> JOIN LPAREN . arglist SEPARE arglist RPAREN RETURNS LPAREN identlist RPAREN LOCALS LPAREN arglist RPAREN block
    (4) joinspec -> JOIN LPAREN . arglist SEPARE arglist RPAREN RETURNS LPAREN identlist RPAREN LOCALS LPAREN arglist RPAREN error
    (6) arglist -> . arglist COMMA arg
    (7) arglist -> . arg
    (8) arglist -> .
    (9) arg -> . type IDENT
    (70) type -> . INT
    (71) type -> . FLOAT
    (72) type -> . BOOL
    (73) type -> . type TIMES

    SEPARE          reduce using rule 8 (arglist -> .)
    COMMA           reduce using rule 8 (arglist -> .)
    INT             shift and go to state 8
    FLOAT           shift and go to state 11
    BOOL            shift and go to state 13

    arglist                        shift and go to state 12
    type                           shift and go to state 9
    arg                            shift and go to state 10

state 5

    (3) joinspec -> JOIN error . RPAREN block

    RPAREN          shift and go to state 14


state 6

    (1) program -> joinspec sequentialspec .

    $end            reduce using rule 1 (program -> joinspec sequentialspec .)


state 7

    (5) sequentialspec -> SEQUENTIAL . LPAREN arglist RPAREN RETURNS LPAREN identlist RPAREN LOCALS LPAREN arglist RPAREN block

    LPAREN          shift and go to state 15


state 8

    (70) type -> INT .

    IDENT           reduce using rule 70 (type -> INT .)
    TIMES           reduce using rule 70 (type -> INT .)


state 9

    (9) arg -> type . IDENT
    (73) type -> type . TIMES

    IDENT           shift and go to state 16
    TIMES           shift and go to state 17


state 10

    (7) arglist -> arg .

    RPAREN          reduce using rule 7 (arglist -> arg .)
    COMMA           reduce using rule 7 (arglist -> arg .)
    SEPARE          reduce using rule 7 (arglist -> arg .)


state 11

    (71) type -> FLOAT .

    IDENT           reduce using rule 71 (type -> FLOAT .)
    TIMES           reduce using rule 71 (type -> FLOAT .)


state 12

    (2) joinspec -> JOIN LPAREN arglist . SEPARE arglist RPAREN RETURNS LPAREN identlist RPAREN LOCALS LPAREN arglist RPAREN block
    (4) joinspec -> JOIN LPAREN arglist . SEPARE arglist RPAREN RETURNS LPAREN identlist RPAREN LOCALS LPAREN arglist RPAREN error
    (6) arglist -> arglist . COMMA arg

    SEPARE          shift and go to state 19
    COMMA           shift and go to state 18


state 13

    (72) type -> BOOL .

    IDENT           reduce using rule 72 (type -> BOOL .)
    TIMES           reduce using rule 72 (type -> BOOL .)


state 14

    (3) joinspec -> JOIN error RPAREN . block
    (68) block -> . LBRACE statementlist RBRACE
    (69) block -> . LBRACE error RBRACE

    LBRACE          shift and go to state 20

    block                          shift and go to state 21

state 15

    (5) sequentialspec -> SEQUENTIAL LPAREN . arglist RPAREN RETURNS LPAREN identlist RPAREN LOCALS LPAREN arglist RPAREN block
    (6) arglist -> . arglist COMMA arg
    (7) arglist -> . arg
    (8) arglist -> .
    (9) arg -> . type IDENT
    (70) type -> . INT
    (71) type -> . FLOAT
    (72) type -> . BOOL
    (73) type -> . type TIMES

    RPAREN          reduce using rule 8 (arglist -> .)
    COMMA           reduce using rule 8 (arglist -> .)
    INT             shift and go to state 8
    FLOAT           shift and go to state 11
    BOOL            shift and go to state 13

    arglist                        shift and go to state 22
    type                           shift and go to state 9
    arg                            shift and go to state 10

state 16

    (9) arg -> type IDENT .

    RPAREN          reduce using rule 9 (arg -> type IDENT .)
    COMMA           reduce using rule 9 (arg -> type IDENT .)
    SEPARE          reduce using rule 9 (arg -> type IDENT .)


state 17

    (73) type -> type TIMES .

    IDENT           reduce using rule 73 (type -> type TIMES .)
    TIMES           reduce using rule 73 (type -> type TIMES .)


state 18

    (6) arglist -> arglist COMMA . arg
    (9) arg -> . type IDENT
    (70) type -> . INT
    (71) type -> . FLOAT
    (72) type -> . BOOL
    (73) type -> . type TIMES

    INT             shift and go to state 8
    FLOAT           shift and go to state 11
    BOOL            shift and go to state 13

    type                           shift and go to state 9
    arg                            shift and go to state 23

state 19

    (2) joinspec -> JOIN LPAREN arglist SEPARE . arglist RPAREN RETURNS LPAREN identlist RPAREN LOCALS LPAREN arglist RPAREN block
    (4) joinspec -> JOIN LPAREN arglist SEPARE . arglist RPAREN RETURNS LPAREN identlist RPAREN LOCALS LPAREN arglist RPAREN error
    (6) arglist -> . arglist COMMA arg
    (7) arglist -> . arg
    (8) arglist -> .
    (9) arg -> . type IDENT
    (70) type -> . INT
    (71) type -> . FLOAT
    (72) type -> . BOOL
    (73) type -> . type TIMES

    RPAREN          reduce using rule 8 (arglist -> .)
    COMMA           reduce using rule 8 (arglist -> .)
    INT             shift and go to state 8
    FLOAT           shift and go to state 11
    BOOL            shift and go to state 13

    arglist                        shift and go to state 24
    type                           shift and go to state 9
    arg                            shift and go to state 10

state 20

    (68) block -> LBRACE . statementlist RBRACE
    (69) block -> LBRACE . error RBRACE
    (55) statementlist -> . statementlist statement
    (56) statementlist -> .

  ! shift/reduce conflict for error resolved as shift
    error           shift and go to state 26
    RBRACE          reduce using rule 56 (statementlist -> .)
    FOR             reduce using rule 56 (statementlist -> .)
    IF              reduce using rule 56 (statementlist -> .)
    LBRACE          reduce using rule 56 (statementlist -> .)
    IDENT           reduce using rule 56 (statementlist -> .)
    LPAREN          reduce using rule 56 (statementlist -> .)
    NUMBER          reduce using rule 56 (statementlist -> .)
    TRUE            reduce using rule 56 (statementlist -> .)
    FALSE           reduce using rule 56 (statementlist -> .)

  ! error           [ reduce using rule 56 (statementlist -> .) ]

    statementlist                  shift and go to state 25

state 21

    (3) joinspec -> JOIN error RPAREN block .

    SEQUENTIAL      reduce using rule 3 (joinspec -> JOIN error RPAREN block .)


state 22

    (5) sequentialspec -> SEQUENTIAL LPAREN arglist . RPAREN RETURNS LPAREN identlist RPAREN LOCALS LPAREN arglist RPAREN block
    (6) arglist -> arglist . COMMA arg

    RPAREN          shift and go to state 27
    COMMA           shift and go to state 18


state 23

    (6) arglist -> arglist COMMA arg .

    RPAREN          reduce using rule 6 (arglist -> arglist COMMA arg .)
    COMMA           reduce using rule 6 (arglist -> arglist COMMA arg .)
    SEPARE          reduce using rule 6 (arglist -> arglist COMMA arg .)


state 24

    (2) joinspec -> JOIN LPAREN arglist SEPARE arglist . RPAREN RETURNS LPAREN identlist RPAREN LOCALS LPAREN arglist RPAREN block
    (4) joinspec -> JOIN LPAREN arglist SEPARE arglist . RPAREN RETURNS LPAREN identlist RPAREN LOCALS LPAREN arglist RPAREN error
    (6) arglist -> arglist . COMMA arg

    RPAREN          shift and go to state 28
    COMMA           shift and go to state 18


state 25

    (68) block -> LBRACE statementlist . RBRACE
    (55) statementlist -> statementlist . statement
    (60) statement -> . assignmentStatement SEMICOLON
    (61) statement -> . iterationStatement
    (62) statement -> . selectionStatement
    (63) statement -> . block
    (64) statement -> . error SEMICOLON
    (57) assignmentStatement -> . postfixExpression EQ expression
    (58) assignmentStatement -> . postfixExpression EQ error
    (59) assignmentStatement -> . error EQ expression
    (67) iterationStatement -> . FOR LPAREN assignmentStatement SEMICOLON expression SEMICOLON assignmentStatement RPAREN statement
    (65) selectionStatement -> . IF LPAREN expression RPAREN statement ELSE statement
    (66) selectionStatement -> . IF LPAREN expression RPAREN statement
    (68) block -> . LBRACE statementlist RBRACE
    (69) block -> . LBRACE error RBRACE
    (16) postfixExpression -> . constant
    (17) postfixExpression -> . IDENT
    (18) postfixExpression -> . LPAREN expression RPAREN
    (19) postfixExpression -> . postfixExpression LBRACKET expression RBRACKET
    (20) postfixExpression -> . IDENT LPAREN expressionlist RPAREN
    (13) constant -> . NUMBER
    (14) constant -> . TRUE
    (15) constant -> . FALSE

    RBRACE          shift and go to state 36
    error           shift and go to state 43
    FOR             shift and go to state 37
    IF              shift and go to state 40
    LBRACE          shift and go to state 20
    IDENT           shift and go to state 35
    LPAREN          shift and go to state 38
    NUMBER          shift and go to state 30
    TRUE            shift and go to state 31
    FALSE           shift and go to state 42

    postfixExpression              shift and go to state 41
    constant                       shift and go to state 29
    block                          shift and go to state 44
    statement                      shift and go to state 33
    assignmentStatement            shift and go to state 34
    iterationStatement             shift and go to state 39
    selectionStatement             shift and go to state 32

state 26

    (69) block -> LBRACE error . RBRACE

    RBRACE          shift and go to state 45


state 27

    (5) sequentialspec -> SEQUENTIAL LPAREN arglist RPAREN . RETURNS LPAREN identlist RPAREN LOCALS LPAREN arglist RPAREN block

    RETURNS         shift and go to state 46


state 28

    (2) joinspec -> JOIN LPAREN arglist SEPARE arglist RPAREN . RETURNS LPAREN identlist RPAREN LOCALS LPAREN arglist RPAREN block
    (4) joinspec -> JOIN LPAREN arglist SEPARE arglist RPAREN . RETURNS LPAREN identlist RPAREN LOCALS LPAREN arglist RPAREN error

    RETURNS         shift and go to state 47


state 29

    (16) postfixExpression -> constant .

    EQ              reduce using rule 16 (postfixExpression -> constant .)
    LBRACKET        reduce using rule 16 (postfixExpression -> constant .)
    PLUS            reduce using rule 16 (postfixExpression -> constant .)
    MINUS           reduce using rule 16 (postfixExpression -> constant .)
    LT              reduce using rule 16 (postfixExpression -> constant .)
    LEQ             reduce using rule 16 (postfixExpression -> constant .)
    GT              reduce using rule 16 (postfixExpression -> constant .)
    GEQ             reduce using rule 16 (postfixExpression -> constant .)
    EQEQ            reduce using rule 16 (postfixExpression -> constant .)
    NEQ             reduce using rule 16 (postfixExpression -> constant .)
    AND             reduce using rule 16 (postfixExpression -> constant .)
    QUESTION        reduce using rule 16 (postfixExpression -> constant .)
    OR              reduce using rule 16 (postfixExpression -> constant .)
    SEMICOLON       reduce using rule 16 (postfixExpression -> constant .)
    RPAREN          reduce using rule 16 (postfixExpression -> constant .)
    COMMA           reduce using rule 16 (postfixExpression -> constant .)
    RBRACKET        reduce using rule 16 (postfixExpression -> constant .)
    COLON           reduce using rule 16 (postfixExpression -> constant .)
    TIMES           reduce using rule 16 (postfixExpression -> constant .)
    DIV             reduce using rule 16 (postfixExpression -> constant .)


state 30

    (13) constant -> NUMBER .

    LBRACKET        reduce using rule 13 (constant -> NUMBER .)
    PLUS            reduce using rule 13 (constant -> NUMBER .)
    MINUS           reduce using rule 13 (constant -> NUMBER .)
    LT              reduce using rule 13 (constant -> NUMBER .)
    LEQ             reduce using rule 13 (constant -> NUMBER .)
    GT              reduce using rule 13 (constant -> NUMBER .)
    GEQ             reduce using rule 13 (constant -> NUMBER .)
    EQEQ            reduce using rule 13 (constant -> NUMBER .)
    NEQ             reduce using rule 13 (constant -> NUMBER .)
    AND             reduce using rule 13 (constant -> NUMBER .)
    QUESTION        reduce using rule 13 (constant -> NUMBER .)
    OR              reduce using rule 13 (constant -> NUMBER .)
    RPAREN          reduce using rule 13 (constant -> NUMBER .)
    COMMA           reduce using rule 13 (constant -> NUMBER .)
    SEMICOLON       reduce using rule 13 (constant -> NUMBER .)
    RBRACKET        reduce using rule 13 (constant -> NUMBER .)
    COLON           reduce using rule 13 (constant -> NUMBER .)
    EQ              reduce using rule 13 (constant -> NUMBER .)
    TIMES           reduce using rule 13 (constant -> NUMBER .)
    DIV             reduce using rule 13 (constant -> NUMBER .)


state 31

    (14) constant -> TRUE .

    LBRACKET        reduce using rule 14 (constant -> TRUE .)
    PLUS            reduce using rule 14 (constant -> TRUE .)
    MINUS           reduce using rule 14 (constant -> TRUE .)
    LT              reduce using rule 14 (constant -> TRUE .)
    LEQ             reduce using rule 14 (constant -> TRUE .)
    GT              reduce using rule 14 (constant -> TRUE .)
    GEQ             reduce using rule 14 (constant -> TRUE .)
    EQEQ            reduce using rule 14 (constant -> TRUE .)
    NEQ             reduce using rule 14 (constant -> TRUE .)
    AND             reduce using rule 14 (constant -> TRUE .)
    QUESTION        reduce using rule 14 (constant -> TRUE .)
    OR              reduce using rule 14 (constant -> TRUE .)
    RPAREN          reduce using rule 14 (constant -> TRUE .)
    COMMA           reduce using rule 14 (constant -> TRUE .)
    SEMICOLON       reduce using rule 14 (constant -> TRUE .)
    RBRACKET        reduce using rule 14 (constant -> TRUE .)
    COLON           reduce using rule 14 (constant -> TRUE .)
    EQ              reduce using rule 14 (constant -> TRUE .)
    TIMES           reduce using rule 14 (constant -> TRUE .)
    DIV             reduce using rule 14 (constant -> TRUE .)


state 32

    (62) statement -> selectionStatement .

    ELSE            reduce using rule 62 (statement -> selectionStatement .)
    RBRACE          reduce using rule 62 (statement -> selectionStatement .)
    error           reduce using rule 62 (statement -> selectionStatement .)
    FOR             reduce using rule 62 (statement -> selectionStatement .)
    IF              reduce using rule 62 (statement -> selectionStatement .)
    LBRACE          reduce using rule 62 (statement -> selectionStatement .)
    IDENT           reduce using rule 62 (statement -> selectionStatement .)
    LPAREN          reduce using rule 62 (statement -> selectionStatement .)
    NUMBER          reduce using rule 62 (statement -> selectionStatement .)
    TRUE            reduce using rule 62 (statement -> selectionStatement .)
    FALSE           reduce using rule 62 (statement -> selectionStatement .)


state 33

    (55) statementlist -> statementlist statement .

    RBRACE          reduce using rule 55 (statementlist -> statementlist statement .)
    error           reduce using rule 55 (statementlist -> statementlist statement .)
    FOR             reduce using rule 55 (statementlist -> statementlist statement .)
    IF              reduce using rule 55 (statementlist -> statementlist statement .)
    LBRACE          reduce using rule 55 (statementlist -> statementlist statement .)
    IDENT           reduce using rule 55 (statementlist -> statementlist statement .)
    LPAREN          reduce using rule 55 (statementlist -> statementlist statement .)
    NUMBER          reduce using rule 55 (statementlist -> statementlist statement .)
    TRUE            reduce using rule 55 (statementlist -> statementlist statement .)
    FALSE           reduce using rule 55 (statementlist -> statementlist statement .)


state 34

    (60) statement -> assignmentStatement . SEMICOLON

    SEMICOLON       shift and go to state 48


state 35

    (17) postfixExpression -> IDENT .
    (20) postfixExpression -> IDENT . LPAREN expressionlist RPAREN

    EQ              reduce using rule 17 (postfixExpression -> IDENT .)
    LBRACKET        reduce using rule 17 (postfixExpression -> IDENT .)
    PLUS            reduce using rule 17 (postfixExpression -> IDENT .)
    MINUS           reduce using rule 17 (postfixExpression -> IDENT .)
    LT              reduce using rule 17 (postfixExpression -> IDENT .)
    LEQ             reduce using rule 17 (postfixExpression -> IDENT .)
    GT              reduce using rule 17 (postfixExpression -> IDENT .)
    GEQ             reduce using rule 17 (postfixExpression -> IDENT .)
    EQEQ            reduce using rule 17 (postfixExpression -> IDENT .)
    NEQ             reduce using rule 17 (postfixExpression -> IDENT .)
    AND             reduce using rule 17 (postfixExpression -> IDENT .)
    QUESTION        reduce using rule 17 (postfixExpression -> IDENT .)
    OR              reduce using rule 17 (postfixExpression -> IDENT .)
    SEMICOLON       reduce using rule 17 (postfixExpression -> IDENT .)
    RPAREN          reduce using rule 17 (postfixExpression -> IDENT .)
    COMMA           reduce using rule 17 (postfixExpression -> IDENT .)
    RBRACKET        reduce using rule 17 (postfixExpression -> IDENT .)
    COLON           reduce using rule 17 (postfixExpression -> IDENT .)
    TIMES           reduce using rule 17 (postfixExpression -> IDENT .)
    DIV             reduce using rule 17 (postfixExpression -> IDENT .)
    LPAREN          shift and go to state 49


state 36

    (68) block -> LBRACE statementlist RBRACE .

    SEQUENTIAL      reduce using rule 68 (block -> LBRACE statementlist RBRACE .)
    RBRACE          reduce using rule 68 (block -> LBRACE statementlist RBRACE .)
    error           reduce using rule 68 (block -> LBRACE statementlist RBRACE .)
    FOR             reduce using rule 68 (block -> LBRACE statementlist RBRACE .)
    IF              reduce using rule 68 (block -> LBRACE statementlist RBRACE .)
    LBRACE          reduce using rule 68 (block -> LBRACE statementlist RBRACE .)
    IDENT           reduce using rule 68 (block -> LBRACE statementlist RBRACE .)
    LPAREN          reduce using rule 68 (block -> LBRACE statementlist RBRACE .)
    NUMBER          reduce using rule 68 (block -> LBRACE statementlist RBRACE .)
    TRUE            reduce using rule 68 (block -> LBRACE statementlist RBRACE .)
    FALSE           reduce using rule 68 (block -> LBRACE statementlist RBRACE .)
    ELSE            reduce using rule 68 (block -> LBRACE statementlist RBRACE .)
    $end            reduce using rule 68 (block -> LBRACE statementlist RBRACE .)


state 37

    (67) iterationStatement -> FOR . LPAREN assignmentStatement SEMICOLON expression SEMICOLON assignmentStatement RPAREN statement

    LPAREN          shift and go to state 50


state 38

    (18) postfixExpression -> LPAREN . expression RPAREN
    (51) expression -> . conditionalExpression
    (49) conditionalExpression -> . orExpression
    (50) conditionalExpression -> . orExpression QUESTION expression COLON expression
    (47) orExpression -> . andExpression
    (48) orExpression -> . orExpression OR andExpression
    (45) andExpression -> . equalityExpression
    (46) andExpression -> . andExpression AND equalityExpression
    (41) equalityExpression -> . relationalExpression
    (42) equalityExpression -> . equalityExpression eqop relationalExpression
    (35) relationalExpression -> . additiveExpression
    (36) relationalExpression -> . relationalExpression compop additiveExpression
    (31) additiveExpression -> . unaryExpression
    (32) additiveExpression -> . additiveExpression addop multiplicativeExpression
    (21) unaryExpression -> . unop unaryExpression
    (22) unaryExpression -> . postfixExpression
    (23) unop -> . PLUS
    (24) unop -> . MINUS
    (25) unop -> . EXCLAMATION
    (26) unop -> . TILDE
    (16) postfixExpression -> . constant
    (17) postfixExpression -> . IDENT
    (18) postfixExpression -> . LPAREN expression RPAREN
    (19) postfixExpression -> . postfixExpression LBRACKET expression RBRACKET
    (20) postfixExpression -> . IDENT LPAREN expressionlist RPAREN
    (13) constant -> . NUMBER
    (14) constant -> . TRUE
    (15) constant -> . FALSE

    PLUS            shift and go to state 55
    MINUS           shift and go to state 53
    EXCLAMATION     shift and go to state 60
    TILDE           shift and go to state 56
    IDENT           shift and go to state 35
    LPAREN          shift and go to state 38
    NUMBER          shift and go to state 30
    TRUE            shift and go to state 31
    FALSE           shift and go to state 42

    equalityExpression             shift and go to state 51
    additiveExpression             shift and go to state 57
    conditionalExpression          shift and go to state 58
    unaryExpression                shift and go to state 59
    orExpression                   shift and go to state 54
    relationalExpression           shift and go to state 61
    unop                           shift and go to state 52
    andExpression                  shift and go to state 62
    postfixExpression              shift and go to state 63
    constant                       shift and go to state 29
    expression                     shift and go to state 64

state 39

    (61) statement -> iterationStatement .

    ELSE            reduce using rule 61 (statement -> iterationStatement .)
    RBRACE          reduce using rule 61 (statement -> iterationStatement .)
    error           reduce using rule 61 (statement -> iterationStatement .)
    FOR             reduce using rule 61 (statement -> iterationStatement .)
    IF              reduce using rule 61 (statement -> iterationStatement .)
    LBRACE          reduce using rule 61 (statement -> iterationStatement .)
    IDENT           reduce using rule 61 (statement -> iterationStatement .)
    LPAREN          reduce using rule 61 (statement -> iterationStatement .)
    NUMBER          reduce using rule 61 (statement -> iterationStatement .)
    TRUE            reduce using rule 61 (statement -> iterationStatement .)
    FALSE           reduce using rule 61 (statement -> iterationStatement .)


state 40

    (65) selectionStatement -> IF . LPAREN expression RPAREN statement ELSE statement
    (66) selectionStatement -> IF . LPAREN expression RPAREN statement

    LPAREN          shift and go to state 65


state 41

    (57) assignmentStatement -> postfixExpression . EQ expression
    (58) assignmentStatement -> postfixExpression . EQ error
    (19) postfixExpression -> postfixExpression . LBRACKET expression RBRACKET

    EQ              shift and go to state 66
    LBRACKET        shift and go to state 67


state 42

    (15) constant -> FALSE .

    LBRACKET        reduce using rule 15 (constant -> FALSE .)
    PLUS            reduce using rule 15 (constant -> FALSE .)
    MINUS           reduce using rule 15 (constant -> FALSE .)
    LT              reduce using rule 15 (constant -> FALSE .)
    LEQ             reduce using rule 15 (constant -> FALSE .)
    GT              reduce using rule 15 (constant -> FALSE .)
    GEQ             reduce using rule 15 (constant -> FALSE .)
    EQEQ            reduce using rule 15 (constant -> FALSE .)
    NEQ             reduce using rule 15 (constant -> FALSE .)
    AND             reduce using rule 15 (constant -> FALSE .)
    QUESTION        reduce using rule 15 (constant -> FALSE .)
    OR              reduce using rule 15 (constant -> FALSE .)
    RPAREN          reduce using rule 15 (constant -> FALSE .)
    COMMA           reduce using rule 15 (constant -> FALSE .)
    SEMICOLON       reduce using rule 15 (constant -> FALSE .)
    RBRACKET        reduce using rule 15 (constant -> FALSE .)
    COLON           reduce using rule 15 (constant -> FALSE .)
    EQ              reduce using rule 15 (constant -> FALSE .)
    TIMES           reduce using rule 15 (constant -> FALSE .)
    DIV             reduce using rule 15 (constant -> FALSE .)


state 43

    (64) statement -> error . SEMICOLON
    (59) assignmentStatement -> error . EQ expression

    SEMICOLON       shift and go to state 69
    EQ              shift and go to state 68


state 44

    (63) statement -> block .

    ELSE            reduce using rule 63 (statement -> block .)
    RBRACE          reduce using rule 63 (statement -> block .)
    error           reduce using rule 63 (statement -> block .)
    FOR             reduce using rule 63 (statement -> block .)
    IF              reduce using rule 63 (statement -> block .)
    LBRACE          reduce using rule 63 (statement -> block .)
    IDENT           reduce using rule 63 (statement -> block .)
    LPAREN          reduce using rule 63 (statement -> block .)
    NUMBER          reduce using rule 63 (statement -> block .)
    TRUE            reduce using rule 63 (statement -> block .)
    FALSE           reduce using rule 63 (statement -> block .)


state 45

    (69) block -> LBRACE error RBRACE .

    SEQUENTIAL      reduce using rule 69 (block -> LBRACE error RBRACE .)
    RBRACE          reduce using rule 69 (block -> LBRACE error RBRACE .)
    error           reduce using rule 69 (block -> LBRACE error RBRACE .)
    FOR             reduce using rule 69 (block -> LBRACE error RBRACE .)
    IF              reduce using rule 69 (block -> LBRACE error RBRACE .)
    LBRACE          reduce using rule 69 (block -> LBRACE error RBRACE .)
    IDENT           reduce using rule 69 (block -> LBRACE error RBRACE .)
    LPAREN          reduce using rule 69 (block -> LBRACE error RBRACE .)
    NUMBER          reduce using rule 69 (block -> LBRACE error RBRACE .)
    TRUE            reduce using rule 69 (block -> LBRACE error RBRACE .)
    FALSE           reduce using rule 69 (block -> LBRACE error RBRACE .)
    ELSE            reduce using rule 69 (block -> LBRACE error RBRACE .)
    $end            reduce using rule 69 (block -> LBRACE error RBRACE .)


state 46

    (5) sequentialspec -> SEQUENTIAL LPAREN arglist RPAREN RETURNS . LPAREN identlist RPAREN LOCALS LPAREN arglist RPAREN block

    LPAREN          shift and go to state 70


state 47

    (2) joinspec -> JOIN LPAREN arglist SEPARE arglist RPAREN RETURNS . LPAREN identlist RPAREN LOCALS LPAREN arglist RPAREN block
    (4) joinspec -> JOIN LPAREN arglist SEPARE arglist RPAREN RETURNS . LPAREN identlist RPAREN LOCALS LPAREN arglist RPAREN error

    LPAREN          shift and go to state 71


state 48

    (60) statement -> assignmentStatement SEMICOLON .

    ELSE            reduce using rule 60 (statement -> assignmentStatement SEMICOLON .)
    RBRACE          reduce using rule 60 (statement -> assignmentStatement SEMICOLON .)
    error           reduce using rule 60 (statement -> assignmentStatement SEMICOLON .)
    FOR             reduce using rule 60 (statement -> assignmentStatement SEMICOLON .)
    IF              reduce using rule 60 (statement -> assignmentStatement SEMICOLON .)
    LBRACE          reduce using rule 60 (statement -> assignmentStatement SEMICOLON .)
    IDENT           reduce using rule 60 (statement -> assignmentStatement SEMICOLON .)
    LPAREN          reduce using rule 60 (statement -> assignmentStatement SEMICOLON .)
    NUMBER          reduce using rule 60 (statement -> assignmentStatement SEMICOLON .)
    TRUE            reduce using rule 60 (statement -> assignmentStatement SEMICOLON .)
    FALSE           reduce using rule 60 (statement -> assignmentStatement SEMICOLON .)


state 49

    (20) postfixExpression -> IDENT LPAREN . expressionlist RPAREN
    (52) expressionlist -> . expression
    (53) expressionlist -> . expressionlist COMMA expression
    (54) expressionlist -> .
    (51) expression -> . conditionalExpression
    (49) conditionalExpression -> . orExpression
    (50) conditionalExpression -> . orExpression QUESTION expression COLON expression
    (47) orExpression -> . andExpression
    (48) orExpression -> . orExpression OR andExpression
    (45) andExpression -> . equalityExpression
    (46) andExpression -> . andExpression AND equalityExpression
    (41) equalityExpression -> . relationalExpression
    (42) equalityExpression -> . equalityExpression eqop relationalExpression
    (35) relationalExpression -> . additiveExpression
    (36) relationalExpression -> . relationalExpression compop additiveExpression
    (31) additiveExpression -> . unaryExpression
    (32) additiveExpression -> . additiveExpression addop multiplicativeExpression
    (21) unaryExpression -> . unop unaryExpression
    (22) unaryExpression -> . postfixExpression
    (23) unop -> . PLUS
    (24) unop -> . MINUS
    (25) unop -> . EXCLAMATION
    (26) unop -> . TILDE
    (16) postfixExpression -> . constant
    (17) postfixExpression -> . IDENT
    (18) postfixExpression -> . LPAREN expression RPAREN
    (19) postfixExpression -> . postfixExpression LBRACKET expression RBRACKET
    (20) postfixExpression -> . IDENT LPAREN expressionlist RPAREN
    (13) constant -> . NUMBER
    (14) constant -> . TRUE
    (15) constant -> . FALSE

    RPAREN          reduce using rule 54 (expressionlist -> .)
    COMMA           reduce using rule 54 (expressionlist -> .)
    PLUS            shift and go to state 55
    MINUS           shift and go to state 53
    EXCLAMATION     shift and go to state 60
    TILDE           shift and go to state 56
    IDENT           shift and go to state 35
    LPAREN          shift and go to state 38
    NUMBER          shift and go to state 30
    TRUE            shift and go to state 31
    FALSE           shift and go to state 42

    equalityExpression             shift and go to state 51
    additiveExpression             shift and go to state 57
    conditionalExpression          shift and go to state 58
    unaryExpression                shift and go to state 59
    orExpression                   shift and go to state 54
    relationalExpression           shift and go to state 61
    unop                           shift and go to state 52
    expressionlist                 shift and go to state 72
    andExpression                  shift and go to state 62
    postfixExpression              shift and go to state 63
    constant                       shift and go to state 29
    expression                     shift and go to state 73

state 50

    (67) iterationStatement -> FOR LPAREN . assignmentStatement SEMICOLON expression SEMICOLON assignmentStatement RPAREN statement
    (57) assignmentStatement -> . postfixExpression EQ expression
    (58) assignmentStatement -> . postfixExpression EQ error
    (59) assignmentStatement -> . error EQ expression
    (16) postfixExpression -> . constant
    (17) postfixExpression -> . IDENT
    (18) postfixExpression -> . LPAREN expression RPAREN
    (19) postfixExpression -> . postfixExpression LBRACKET expression RBRACKET
    (20) postfixExpression -> . IDENT LPAREN expressionlist RPAREN
    (13) constant -> . NUMBER
    (14) constant -> . TRUE
    (15) constant -> . FALSE

    error           shift and go to state 74
    IDENT           shift and go to state 35
    LPAREN          shift and go to state 38
    NUMBER          shift and go to state 30
    TRUE            shift and go to state 31
    FALSE           shift and go to state 42

    postfixExpression              shift and go to state 41
    constant                       shift and go to state 29
    assignmentStatement            shift and go to state 75

state 51

    (45) andExpression -> equalityExpression .
    (42) equalityExpression -> equalityExpression . eqop relationalExpression
    (43) eqop -> . EQEQ
    (44) eqop -> . NEQ

    AND             reduce using rule 45 (andExpression -> equalityExpression .)
    QUESTION        reduce using rule 45 (andExpression -> equalityExpression .)
    OR              reduce using rule 45 (andExpression -> equalityExpression .)
    RBRACKET        reduce using rule 45 (andExpression -> equalityExpression .)
    RPAREN          reduce using rule 45 (andExpression -> equalityExpression .)
    COMMA           reduce using rule 45 (andExpression -> equalityExpression .)
    SEMICOLON       reduce using rule 45 (andExpression -> equalityExpression .)
    COLON           reduce using rule 45 (andExpression -> equalityExpression .)
    EQEQ            shift and go to state 76
    NEQ             shift and go to state 78

    eqop                           shift and go to state 77

state 52

    (21) unaryExpression -> unop . unaryExpression
    (21) unaryExpression -> . unop unaryExpression
    (22) unaryExpression -> . postfixExpression
    (23) unop -> . PLUS
    (24) unop -> . MINUS
    (25) unop -> . EXCLAMATION
    (26) unop -> . TILDE
    (16) postfixExpression -> . constant
    (17) postfixExpression -> . IDENT
    (18) postfixExpression -> . LPAREN expression RPAREN
    (19) postfixExpression -> . postfixExpression LBRACKET expression RBRACKET
    (20) postfixExpression -> . IDENT LPAREN expressionlist RPAREN
    (13) constant -> . NUMBER
    (14) constant -> . TRUE
    (15) constant -> . FALSE

    PLUS            shift and go to state 55
    MINUS           shift and go to state 53
    EXCLAMATION     shift and go to state 60
    TILDE           shift and go to state 56
    IDENT           shift and go to state 35
    LPAREN          shift and go to state 38
    NUMBER          shift and go to state 30
    TRUE            shift and go to state 31
    FALSE           shift and go to state 42

    unop                           shift and go to state 52
    postfixExpression              shift and go to state 63
    constant                       shift and go to state 29
    unaryExpression                shift and go to state 79

state 53

    (24) unop -> MINUS .

    PLUS            reduce using rule 24 (unop -> MINUS .)
    MINUS           reduce using rule 24 (unop -> MINUS .)
    EXCLAMATION     reduce using rule 24 (unop -> MINUS .)
    TILDE           reduce using rule 24 (unop -> MINUS .)
    IDENT           reduce using rule 24 (unop -> MINUS .)
    LPAREN          reduce using rule 24 (unop -> MINUS .)
    NUMBER          reduce using rule 24 (unop -> MINUS .)
    TRUE            reduce using rule 24 (unop -> MINUS .)
    FALSE           reduce using rule 24 (unop -> MINUS .)


state 54

    (49) conditionalExpression -> orExpression .
    (50) conditionalExpression -> orExpression . QUESTION expression COLON expression
    (48) orExpression -> orExpression . OR andExpression

    COLON           reduce using rule 49 (conditionalExpression -> orExpression .)
    RPAREN          reduce using rule 49 (conditionalExpression -> orExpression .)
    COMMA           reduce using rule 49 (conditionalExpression -> orExpression .)
    SEMICOLON       reduce using rule 49 (conditionalExpression -> orExpression .)
    RBRACKET        reduce using rule 49 (conditionalExpression -> orExpression .)
    QUESTION        shift and go to state 80
    OR              shift and go to state 81


state 55

    (23) unop -> PLUS .

    PLUS            reduce using rule 23 (unop -> PLUS .)
    MINUS           reduce using rule 23 (unop -> PLUS .)
    EXCLAMATION     reduce using rule 23 (unop -> PLUS .)
    TILDE           reduce using rule 23 (unop -> PLUS .)
    IDENT           reduce using rule 23 (unop -> PLUS .)
    LPAREN          reduce using rule 23 (unop -> PLUS .)
    NUMBER          reduce using rule 23 (unop -> PLUS .)
    TRUE            reduce using rule 23 (unop -> PLUS .)
    FALSE           reduce using rule 23 (unop -> PLUS .)


state 56

    (26) unop -> TILDE .

    PLUS            reduce using rule 26 (unop -> TILDE .)
    MINUS           reduce using rule 26 (unop -> TILDE .)
    EXCLAMATION     reduce using rule 26 (unop -> TILDE .)
    TILDE           reduce using rule 26 (unop -> TILDE .)
    IDENT           reduce using rule 26 (unop -> TILDE .)
    LPAREN          reduce using rule 26 (unop -> TILDE .)
    NUMBER          reduce using rule 26 (unop -> TILDE .)
    TRUE            reduce using rule 26 (unop -> TILDE .)
    FALSE           reduce using rule 26 (unop -> TILDE .)


state 57

    (35) relationalExpression -> additiveExpression .
    (32) additiveExpression -> additiveExpression . addop multiplicativeExpression
    (33) addop -> . PLUS
    (34) addop -> . MINUS

    LT              reduce using rule 35 (relationalExpression -> additiveExpression .)
    LEQ             reduce using rule 35 (relationalExpression -> additiveExpression .)
    GT              reduce using rule 35 (relationalExpression -> additiveExpression .)
    GEQ             reduce using rule 35 (relationalExpression -> additiveExpression .)
    EQEQ            reduce using rule 35 (relationalExpression -> additiveExpression .)
    NEQ             reduce using rule 35 (relationalExpression -> additiveExpression .)
    AND             reduce using rule 35 (relationalExpression -> additiveExpression .)
    QUESTION        reduce using rule 35 (relationalExpression -> additiveExpression .)
    OR              reduce using rule 35 (relationalExpression -> additiveExpression .)
    COLON           reduce using rule 35 (relationalExpression -> additiveExpression .)
    SEMICOLON       reduce using rule 35 (relationalExpression -> additiveExpression .)
    RPAREN          reduce using rule 35 (relationalExpression -> additiveExpression .)
    COMMA           reduce using rule 35 (relationalExpression -> additiveExpression .)
    RBRACKET        reduce using rule 35 (relationalExpression -> additiveExpression .)
    PLUS            shift and go to state 83
    MINUS           shift and go to state 84

    addop                          shift and go to state 82

state 58

    (51) expression -> conditionalExpression .

    RBRACKET        reduce using rule 51 (expression -> conditionalExpression .)
    SEMICOLON       reduce using rule 51 (expression -> conditionalExpression .)
    RPAREN          reduce using rule 51 (expression -> conditionalExpression .)
    COMMA           reduce using rule 51 (expression -> conditionalExpression .)
    COLON           reduce using rule 51 (expression -> conditionalExpression .)


state 59

    (31) additiveExpression -> unaryExpression .

    PLUS            reduce using rule 31 (additiveExpression -> unaryExpression .)
    MINUS           reduce using rule 31 (additiveExpression -> unaryExpression .)
    LT              reduce using rule 31 (additiveExpression -> unaryExpression .)
    LEQ             reduce using rule 31 (additiveExpression -> unaryExpression .)
    GT              reduce using rule 31 (additiveExpression -> unaryExpression .)
    GEQ             reduce using rule 31 (additiveExpression -> unaryExpression .)
    EQEQ            reduce using rule 31 (additiveExpression -> unaryExpression .)
    NEQ             reduce using rule 31 (additiveExpression -> unaryExpression .)
    AND             reduce using rule 31 (additiveExpression -> unaryExpression .)
    QUESTION        reduce using rule 31 (additiveExpression -> unaryExpression .)
    OR              reduce using rule 31 (additiveExpression -> unaryExpression .)
    RPAREN          reduce using rule 31 (additiveExpression -> unaryExpression .)
    COMMA           reduce using rule 31 (additiveExpression -> unaryExpression .)
    SEMICOLON       reduce using rule 31 (additiveExpression -> unaryExpression .)
    RBRACKET        reduce using rule 31 (additiveExpression -> unaryExpression .)
    COLON           reduce using rule 31 (additiveExpression -> unaryExpression .)


state 60

    (25) unop -> EXCLAMATION .

    PLUS            reduce using rule 25 (unop -> EXCLAMATION .)
    MINUS           reduce using rule 25 (unop -> EXCLAMATION .)
    EXCLAMATION     reduce using rule 25 (unop -> EXCLAMATION .)
    TILDE           reduce using rule 25 (unop -> EXCLAMATION .)
    IDENT           reduce using rule 25 (unop -> EXCLAMATION .)
    LPAREN          reduce using rule 25 (unop -> EXCLAMATION .)
    NUMBER          reduce using rule 25 (unop -> EXCLAMATION .)
    TRUE            reduce using rule 25 (unop -> EXCLAMATION .)
    FALSE           reduce using rule 25 (unop -> EXCLAMATION .)


state 61

    (41) equalityExpression -> relationalExpression .
    (36) relationalExpression -> relationalExpression . compop additiveExpression
    (37) compop -> . LT
    (38) compop -> . LEQ
    (39) compop -> . GT
    (40) compop -> . GEQ

    EQEQ            reduce using rule 41 (equalityExpression -> relationalExpression .)
    NEQ             reduce using rule 41 (equalityExpression -> relationalExpression .)
    AND             reduce using rule 41 (equalityExpression -> relationalExpression .)
    QUESTION        reduce using rule 41 (equalityExpression -> relationalExpression .)
    OR              reduce using rule 41 (equalityExpression -> relationalExpression .)
    SEMICOLON       reduce using rule 41 (equalityExpression -> relationalExpression .)
    RPAREN          reduce using rule 41 (equalityExpression -> relationalExpression .)
    COMMA           reduce using rule 41 (equalityExpression -> relationalExpression .)
    RBRACKET        reduce using rule 41 (equalityExpression -> relationalExpression .)
    COLON           reduce using rule 41 (equalityExpression -> relationalExpression .)
    LT              shift and go to state 89
    LEQ             shift and go to state 87
    GT              shift and go to state 86
    GEQ             shift and go to state 85

    compop                         shift and go to state 88

state 62

    (47) orExpression -> andExpression .
    (46) andExpression -> andExpression . AND equalityExpression

    QUESTION        reduce using rule 47 (orExpression -> andExpression .)
    OR              reduce using rule 47 (orExpression -> andExpression .)
    RPAREN          reduce using rule 47 (orExpression -> andExpression .)
    COMMA           reduce using rule 47 (orExpression -> andExpression .)
    COLON           reduce using rule 47 (orExpression -> andExpression .)
    SEMICOLON       reduce using rule 47 (orExpression -> andExpression .)
    RBRACKET        reduce using rule 47 (orExpression -> andExpression .)
    AND             shift and go to state 90


state 63

    (22) unaryExpression -> postfixExpression .
    (19) postfixExpression -> postfixExpression . LBRACKET expression RBRACKET

    PLUS            reduce using rule 22 (unaryExpression -> postfixExpression .)
    MINUS           reduce using rule 22 (unaryExpression -> postfixExpression .)
    LT              reduce using rule 22 (unaryExpression -> postfixExpression .)
    LEQ             reduce using rule 22 (unaryExpression -> postfixExpression .)
    GT              reduce using rule 22 (unaryExpression -> postfixExpression .)
    GEQ             reduce using rule 22 (unaryExpression -> postfixExpression .)
    EQEQ            reduce using rule 22 (unaryExpression -> postfixExpression .)
    NEQ             reduce using rule 22 (unaryExpression -> postfixExpression .)
    AND             reduce using rule 22 (unaryExpression -> postfixExpression .)
    QUESTION        reduce using rule 22 (unaryExpression -> postfixExpression .)
    OR              reduce using rule 22 (unaryExpression -> postfixExpression .)
    SEMICOLON       reduce using rule 22 (unaryExpression -> postfixExpression .)
    RPAREN          reduce using rule 22 (unaryExpression -> postfixExpression .)
    COMMA           reduce using rule 22 (unaryExpression -> postfixExpression .)
    RBRACKET        reduce using rule 22 (unaryExpression -> postfixExpression .)
    COLON           reduce using rule 22 (unaryExpression -> postfixExpression .)
    TIMES           reduce using rule 22 (unaryExpression -> postfixExpression .)
    DIV             reduce using rule 22 (unaryExpression -> postfixExpression .)
    LBRACKET        shift and go to state 67


state 64

    (18) postfixExpression -> LPAREN expression . RPAREN

    RPAREN          shift and go to state 91


state 65

    (65) selectionStatement -> IF LPAREN . expression RPAREN statement ELSE statement
    (66) selectionStatement -> IF LPAREN . expression RPAREN statement
    (51) expression -> . conditionalExpression
    (49) conditionalExpression -> . orExpression
    (50) conditionalExpression -> . orExpression QUESTION expression COLON expression
    (47) orExpression -> . andExpression
    (48) orExpression -> . orExpression OR andExpression
    (45) andExpression -> . equalityExpression
    (46) andExpression -> . andExpression AND equalityExpression
    (41) equalityExpression -> . relationalExpression
    (42) equalityExpression -> . equalityExpression eqop relationalExpression
    (35) relationalExpression -> . additiveExpression
    (36) relationalExpression -> . relationalExpression compop additiveExpression
    (31) additiveExpression -> . unaryExpression
    (32) additiveExpression -> . additiveExpression addop multiplicativeExpression
    (21) unaryExpression -> . unop unaryExpression
    (22) unaryExpression -> . postfixExpression
    (23) unop -> . PLUS
    (24) unop -> . MINUS
    (25) unop -> . EXCLAMATION
    (26) unop -> . TILDE
    (16) postfixExpression -> . constant
    (17) postfixExpression -> . IDENT
    (18) postfixExpression -> . LPAREN expression RPAREN
    (19) postfixExpression -> . postfixExpression LBRACKET expression RBRACKET
    (20) postfixExpression -> . IDENT LPAREN expressionlist RPAREN
    (13) constant -> . NUMBER
    (14) constant -> . TRUE
    (15) constant -> . FALSE

    PLUS            shift and go to state 55
    MINUS           shift and go to state 53
    EXCLAMATION     shift and go to state 60
    TILDE           shift and go to state 56
    IDENT           shift and go to state 35
    LPAREN          shift and go to state 38
    NUMBER          shift and go to state 30
    TRUE            shift and go to state 31
    FALSE           shift and go to state 42

    equalityExpression             shift and go to state 51
    additiveExpression             shift and go to state 57
    conditionalExpression          shift and go to state 58
    unaryExpression                shift and go to state 59
    orExpression                   shift and go to state 54
    relationalExpression           shift and go to state 61
    unop                           shift and go to state 52
    andExpression                  shift and go to state 62
    postfixExpression              shift and go to state 63
    constant                       shift and go to state 29
    expression                     shift and go to state 92

state 66

    (57) assignmentStatement -> postfixExpression EQ . expression
    (58) assignmentStatement -> postfixExpression EQ . error
    (51) expression -> . conditionalExpression
    (49) conditionalExpression -> . orExpression
    (50) conditionalExpression -> . orExpression QUESTION expression COLON expression
    (47) orExpression -> . andExpression
    (48) orExpression -> . orExpression OR andExpression
    (45) andExpression -> . equalityExpression
    (46) andExpression -> . andExpression AND equalityExpression
    (41) equalityExpression -> . relationalExpression
    (42) equalityExpression -> . equalityExpression eqop relationalExpression
    (35) relationalExpression -> . additiveExpression
    (36) relationalExpression -> . relationalExpression compop additiveExpression
    (31) additiveExpression -> . unaryExpression
    (32) additiveExpression -> . additiveExpression addop multiplicativeExpression
    (21) unaryExpression -> . unop unaryExpression
    (22) unaryExpression -> . postfixExpression
    (23) unop -> . PLUS
    (24) unop -> . MINUS
    (25) unop -> . EXCLAMATION
    (26) unop -> . TILDE
    (16) postfixExpression -> . constant
    (17) postfixExpression -> . IDENT
    (18) postfixExpression -> . LPAREN expression RPAREN
    (19) postfixExpression -> . postfixExpression LBRACKET expression RBRACKET
    (20) postfixExpression -> . IDENT LPAREN expressionlist RPAREN
    (13) constant -> . NUMBER
    (14) constant -> . TRUE
    (15) constant -> . FALSE

    error           shift and go to state 93
    PLUS            shift and go to state 55
    MINUS           shift and go to state 53
    EXCLAMATION     shift and go to state 60
    TILDE           shift and go to state 56
    IDENT           shift and go to state 35
    LPAREN          shift and go to state 38
    NUMBER          shift and go to state 30
    TRUE            shift and go to state 31
    FALSE           shift and go to state 42

    postfixExpression              shift and go to state 63
    equalityExpression             shift and go to state 51
    conditionalExpression          shift and go to state 58
    unaryExpression                shift and go to state 59
    orExpression                   shift and go to state 54
    relationalExpression           shift and go to state 61
    unop                           shift and go to state 52
    andExpression                  shift and go to state 62
    constant                       shift and go to state 29
    additiveExpression             shift and go to state 57
    expression                     shift and go to state 94

state 67

    (19) postfixExpression -> postfixExpression LBRACKET . expression RBRACKET
    (51) expression -> . conditionalExpression
    (49) conditionalExpression -> . orExpression
    (50) conditionalExpression -> . orExpression QUESTION expression COLON expression
    (47) orExpression -> . andExpression
    (48) orExpression -> . orExpression OR andExpression
    (45) andExpression -> . equalityExpression
    (46) andExpression -> . andExpression AND equalityExpression
    (41) equalityExpression -> . relationalExpression
    (42) equalityExpression -> . equalityExpression eqop relationalExpression
    (35) relationalExpression -> . additiveExpression
    (36) relationalExpression -> . relationalExpression compop additiveExpression
    (31) additiveExpression -> . unaryExpression
    (32) additiveExpression -> . additiveExpression addop multiplicativeExpression
    (21) unaryExpression -> . unop unaryExpression
    (22) unaryExpression -> . postfixExpression
    (23) unop -> . PLUS
    (24) unop -> . MINUS
    (25) unop -> . EXCLAMATION
    (26) unop -> . TILDE
    (16) postfixExpression -> . constant
    (17) postfixExpression -> . IDENT
    (18) postfixExpression -> . LPAREN expression RPAREN
    (19) postfixExpression -> . postfixExpression LBRACKET expression RBRACKET
    (20) postfixExpression -> . IDENT LPAREN expressionlist RPAREN
    (13) constant -> . NUMBER
    (14) constant -> . TRUE
    (15) constant -> . FALSE

    PLUS            shift and go to state 55
    MINUS           shift and go to state 53
    EXCLAMATION     shift and go to state 60
    TILDE           shift and go to state 56
    IDENT           shift and go to state 35
    LPAREN          shift and go to state 38
    NUMBER          shift and go to state 30
    TRUE            shift and go to state 31
    FALSE           shift and go to state 42

    postfixExpression              shift and go to state 63
    equalityExpression             shift and go to state 51
    conditionalExpression          shift and go to state 58
    unaryExpression                shift and go to state 59
    orExpression                   shift and go to state 54
    relationalExpression           shift and go to state 61
    unop                           shift and go to state 52
    andExpression                  shift and go to state 62
    constant                       shift and go to state 29
    additiveExpression             shift and go to state 57
    expression                     shift and go to state 95

state 68

    (59) assignmentStatement -> error EQ . expression
    (51) expression -> . conditionalExpression
    (49) conditionalExpression -> . orExpression
    (50) conditionalExpression -> . orExpression QUESTION expression COLON expression
    (47) orExpression -> . andExpression
    (48) orExpression -> . orExpression OR andExpression
    (45) andExpression -> . equalityExpression
    (46) andExpression -> . andExpression AND equalityExpression
    (41) equalityExpression -> . relationalExpression
    (42) equalityExpression -> . equalityExpression eqop relationalExpression
    (35) relationalExpression -> . additiveExpression
    (36) relationalExpression -> . relationalExpression compop additiveExpression
    (31) additiveExpression -> . unaryExpression
    (32) additiveExpression -> . additiveExpression addop multiplicativeExpression
    (21) unaryExpression -> . unop unaryExpression
    (22) unaryExpression -> . postfixExpression
    (23) unop -> . PLUS
    (24) unop -> . MINUS
    (25) unop -> . EXCLAMATION
    (26) unop -> . TILDE
    (16) postfixExpression -> . constant
    (17) postfixExpression -> . IDENT
    (18) postfixExpression -> . LPAREN expression RPAREN
    (19) postfixExpression -> . postfixExpression LBRACKET expression RBRACKET
    (20) postfixExpression -> . IDENT LPAREN expressionlist RPAREN
    (13) constant -> . NUMBER
    (14) constant -> . TRUE
    (15) constant -> . FALSE

    PLUS            shift and go to state 55
    MINUS           shift and go to state 53
    EXCLAMATION     shift and go to state 60
    TILDE           shift and go to state 56
    IDENT           shift and go to state 35
    LPAREN          shift and go to state 38
    NUMBER          shift and go to state 30
    TRUE            shift and go to state 31
    FALSE           shift and go to state 42

    equalityExpression             shift and go to state 51
    additiveExpression             shift and go to state 57
    conditionalExpression          shift and go to state 58
    unaryExpression                shift and go to state 59
    orExpression                   shift and go to state 54
    relationalExpression           shift and go to state 61
    unop                           shift and go to state 52
    andExpression                  shift and go to state 62
    postfixExpression              shift and go to state 63
    constant                       shift and go to state 29
    expression                     shift and go to state 96

state 69

    (64) statement -> error SEMICOLON .

    ELSE            reduce using rule 64 (statement -> error SEMICOLON .)
    RBRACE          reduce using rule 64 (statement -> error SEMICOLON .)
    error           reduce using rule 64 (statement -> error SEMICOLON .)
    FOR             reduce using rule 64 (statement -> error SEMICOLON .)
    IF              reduce using rule 64 (statement -> error SEMICOLON .)
    LBRACE          reduce using rule 64 (statement -> error SEMICOLON .)
    IDENT           reduce using rule 64 (statement -> error SEMICOLON .)
    LPAREN          reduce using rule 64 (statement -> error SEMICOLON .)
    NUMBER          reduce using rule 64 (statement -> error SEMICOLON .)
    TRUE            reduce using rule 64 (statement -> error SEMICOLON .)
    FALSE           reduce using rule 64 (statement -> error SEMICOLON .)


state 70

    (5) sequentialspec -> SEQUENTIAL LPAREN arglist RPAREN RETURNS LPAREN . identlist RPAREN LOCALS LPAREN arglist RPAREN block
    (10) identlist -> . IDENT
    (11) identlist -> . IDENT COMMA identlist
    (12) identlist -> .

    IDENT           shift and go to state 98
    RPAREN          reduce using rule 12 (identlist -> .)

    identlist                      shift and go to state 97

state 71

    (2) joinspec -> JOIN LPAREN arglist SEPARE arglist RPAREN RETURNS LPAREN . identlist RPAREN LOCALS LPAREN arglist RPAREN block
    (4) joinspec -> JOIN LPAREN arglist SEPARE arglist RPAREN RETURNS LPAREN . identlist RPAREN LOCALS LPAREN arglist RPAREN error
    (10) identlist -> . IDENT
    (11) identlist -> . IDENT COMMA identlist
    (12) identlist -> .

    IDENT           shift and go to state 98
    RPAREN          reduce using rule 12 (identlist -> .)

    identlist                      shift and go to state 99

state 72

    (20) postfixExpression -> IDENT LPAREN expressionlist . RPAREN
    (53) expressionlist -> expressionlist . COMMA expression

    RPAREN          shift and go to state 100
    COMMA           shift and go to state 101


state 73

    (52) expressionlist -> expression .

    RPAREN          reduce using rule 52 (expressionlist -> expression .)
    COMMA           reduce using rule 52 (expressionlist -> expression .)


state 74

    (59) assignmentStatement -> error . EQ expression

    EQ              shift and go to state 68


state 75

    (67) iterationStatement -> FOR LPAREN assignmentStatement . SEMICOLON expression SEMICOLON assignmentStatement RPAREN statement

    SEMICOLON       shift and go to state 102


state 76

    (43) eqop -> EQEQ .

    PLUS            reduce using rule 43 (eqop -> EQEQ .)
    MINUS           reduce using rule 43 (eqop -> EQEQ .)
    EXCLAMATION     reduce using rule 43 (eqop -> EQEQ .)
    TILDE           reduce using rule 43 (eqop -> EQEQ .)
    IDENT           reduce using rule 43 (eqop -> EQEQ .)
    LPAREN          reduce using rule 43 (eqop -> EQEQ .)
    NUMBER          reduce using rule 43 (eqop -> EQEQ .)
    TRUE            reduce using rule 43 (eqop -> EQEQ .)
    FALSE           reduce using rule 43 (eqop -> EQEQ .)


state 77

    (42) equalityExpression -> equalityExpression eqop . relationalExpression
    (35) relationalExpression -> . additiveExpression
    (36) relationalExpression -> . relationalExpression compop additiveExpression
    (31) additiveExpression -> . unaryExpression
    (32) additiveExpression -> . additiveExpression addop multiplicativeExpression
    (21) unaryExpression -> . unop unaryExpression
    (22) unaryExpression -> . postfixExpression
    (23) unop -> . PLUS
    (24) unop -> . MINUS
    (25) unop -> . EXCLAMATION
    (26) unop -> . TILDE
    (16) postfixExpression -> . constant
    (17) postfixExpression -> . IDENT
    (18) postfixExpression -> . LPAREN expression RPAREN
    (19) postfixExpression -> . postfixExpression LBRACKET expression RBRACKET
    (20) postfixExpression -> . IDENT LPAREN expressionlist RPAREN
    (13) constant -> . NUMBER
    (14) constant -> . TRUE
    (15) constant -> . FALSE

    PLUS            shift and go to state 55
    MINUS           shift and go to state 53
    EXCLAMATION     shift and go to state 60
    TILDE           shift and go to state 56
    IDENT           shift and go to state 35
    LPAREN          shift and go to state 38
    NUMBER          shift and go to state 30
    TRUE            shift and go to state 31
    FALSE           shift and go to state 42

    additiveExpression             shift and go to state 57
    unaryExpression                shift and go to state 59
    relationalExpression           shift and go to state 103
    unop                           shift and go to state 52
    postfixExpression              shift and go to state 63
    constant                       shift and go to state 29

state 78

    (44) eqop -> NEQ .

    PLUS            reduce using rule 44 (eqop -> NEQ .)
    MINUS           reduce using rule 44 (eqop -> NEQ .)
    EXCLAMATION     reduce using rule 44 (eqop -> NEQ .)
    TILDE           reduce using rule 44 (eqop -> NEQ .)
    IDENT           reduce using rule 44 (eqop -> NEQ .)
    LPAREN          reduce using rule 44 (eqop -> NEQ .)
    NUMBER          reduce using rule 44 (eqop -> NEQ .)
    TRUE            reduce using rule 44 (eqop -> NEQ .)
    FALSE           reduce using rule 44 (eqop -> NEQ .)


state 79

    (21) unaryExpression -> unop unaryExpression .

    PLUS            reduce using rule 21 (unaryExpression -> unop unaryExpression .)
    MINUS           reduce using rule 21 (unaryExpression -> unop unaryExpression .)
    LT              reduce using rule 21 (unaryExpression -> unop unaryExpression .)
    LEQ             reduce using rule 21 (unaryExpression -> unop unaryExpression .)
    GT              reduce using rule 21 (unaryExpression -> unop unaryExpression .)
    GEQ             reduce using rule 21 (unaryExpression -> unop unaryExpression .)
    EQEQ            reduce using rule 21 (unaryExpression -> unop unaryExpression .)
    NEQ             reduce using rule 21 (unaryExpression -> unop unaryExpression .)
    AND             reduce using rule 21 (unaryExpression -> unop unaryExpression .)
    QUESTION        reduce using rule 21 (unaryExpression -> unop unaryExpression .)
    OR              reduce using rule 21 (unaryExpression -> unop unaryExpression .)
    SEMICOLON       reduce using rule 21 (unaryExpression -> unop unaryExpression .)
    RPAREN          reduce using rule 21 (unaryExpression -> unop unaryExpression .)
    COMMA           reduce using rule 21 (unaryExpression -> unop unaryExpression .)
    RBRACKET        reduce using rule 21 (unaryExpression -> unop unaryExpression .)
    COLON           reduce using rule 21 (unaryExpression -> unop unaryExpression .)
    TIMES           reduce using rule 21 (unaryExpression -> unop unaryExpression .)
    DIV             reduce using rule 21 (unaryExpression -> unop unaryExpression .)


state 80

    (50) conditionalExpression -> orExpression QUESTION . expression COLON expression
    (51) expression -> . conditionalExpression
    (49) conditionalExpression -> . orExpression
    (50) conditionalExpression -> . orExpression QUESTION expression COLON expression
    (47) orExpression -> . andExpression
    (48) orExpression -> . orExpression OR andExpression
    (45) andExpression -> . equalityExpression
    (46) andExpression -> . andExpression AND equalityExpression
    (41) equalityExpression -> . relationalExpression
    (42) equalityExpression -> . equalityExpression eqop relationalExpression
    (35) relationalExpression -> . additiveExpression
    (36) relationalExpression -> . relationalExpression compop additiveExpression
    (31) additiveExpression -> . unaryExpression
    (32) additiveExpression -> . additiveExpression addop multiplicativeExpression
    (21) unaryExpression -> . unop unaryExpression
    (22) unaryExpression -> . postfixExpression
    (23) unop -> . PLUS
    (24) unop -> . MINUS
    (25) unop -> . EXCLAMATION
    (26) unop -> . TILDE
    (16) postfixExpression -> . constant
    (17) postfixExpression -> . IDENT
    (18) postfixExpression -> . LPAREN expression RPAREN
    (19) postfixExpression -> . postfixExpression LBRACKET expression RBRACKET
    (20) postfixExpression -> . IDENT LPAREN expressionlist RPAREN
    (13) constant -> . NUMBER
    (14) constant -> . TRUE
    (15) constant -> . FALSE

    PLUS            shift and go to state 55
    MINUS           shift and go to state 53
    EXCLAMATION     shift and go to state 60
    TILDE           shift and go to state 56
    IDENT           shift and go to state 35
    LPAREN          shift and go to state 38
    NUMBER          shift and go to state 30
    TRUE            shift and go to state 31
    FALSE           shift and go to state 42

    equalityExpression             shift and go to state 51
    additiveExpression             shift and go to state 57
    conditionalExpression          shift and go to state 58
    unaryExpression                shift and go to state 59
    orExpression                   shift and go to state 54
    relationalExpression           shift and go to state 61
    unop                           shift and go to state 52
    andExpression                  shift and go to state 62
    postfixExpression              shift and go to state 63
    constant                       shift and go to state 29
    expression                     shift and go to state 104

state 81

    (48) orExpression -> orExpression OR . andExpression
    (45) andExpression -> . equalityExpression
    (46) andExpression -> . andExpression AND equalityExpression
    (41) equalityExpression -> . relationalExpression
    (42) equalityExpression -> . equalityExpression eqop relationalExpression
    (35) relationalExpression -> . additiveExpression
    (36) relationalExpression -> . relationalExpression compop additiveExpression
    (31) additiveExpression -> . unaryExpression
    (32) additiveExpression -> . additiveExpression addop multiplicativeExpression
    (21) unaryExpression -> . unop unaryExpression
    (22) unaryExpression -> . postfixExpression
    (23) unop -> . PLUS
    (24) unop -> . MINUS
    (25) unop -> . EXCLAMATION
    (26) unop -> . TILDE
    (16) postfixExpression -> . constant
    (17) postfixExpression -> . IDENT
    (18) postfixExpression -> . LPAREN expression RPAREN
    (19) postfixExpression -> . postfixExpression LBRACKET expression RBRACKET
    (20) postfixExpression -> . IDENT LPAREN expressionlist RPAREN
    (13) constant -> . NUMBER
    (14) constant -> . TRUE
    (15) constant -> . FALSE

    PLUS            shift and go to state 55
    MINUS           shift and go to state 53
    EXCLAMATION     shift and go to state 60
    TILDE           shift and go to state 56
    IDENT           shift and go to state 35
    LPAREN          shift and go to state 38
    NUMBER          shift and go to state 30
    TRUE            shift and go to state 31
    FALSE           shift and go to state 42

    equalityExpression             shift and go to state 51
    additiveExpression             shift and go to state 57
    unaryExpression                shift and go to state 59
    relationalExpression           shift and go to state 61
    unop                           shift and go to state 52
    andExpression                  shift and go to state 105
    postfixExpression              shift and go to state 63
    constant                       shift and go to state 29

state 82

    (32) additiveExpression -> additiveExpression addop . multiplicativeExpression
    (27) multiplicativeExpression -> . unaryExpression
    (28) multiplicativeExpression -> . multiplicativeExpression multop unaryExpression
    (21) unaryExpression -> . unop unaryExpression
    (22) unaryExpression -> . postfixExpression
    (23) unop -> . PLUS
    (24) unop -> . MINUS
    (25) unop -> . EXCLAMATION
    (26) unop -> . TILDE
    (16) postfixExpression -> . constant
    (17) postfixExpression -> . IDENT
    (18) postfixExpression -> . LPAREN expression RPAREN
    (19) postfixExpression -> . postfixExpression LBRACKET expression RBRACKET
    (20) postfixExpression -> . IDENT LPAREN expressionlist RPAREN
    (13) constant -> . NUMBER
    (14) constant -> . TRUE
    (15) constant -> . FALSE

    PLUS            shift and go to state 55
    MINUS           shift and go to state 53
    EXCLAMATION     shift and go to state 60
    TILDE           shift and go to state 56
    IDENT           shift and go to state 35
    LPAREN          shift and go to state 38
    NUMBER          shift and go to state 30
    TRUE            shift and go to state 31
    FALSE           shift and go to state 42

    unaryExpression                shift and go to state 107
    multiplicativeExpression       shift and go to state 106
    unop                           shift and go to state 52
    postfixExpression              shift and go to state 63
    constant                       shift and go to state 29

state 83

    (33) addop -> PLUS .

    PLUS            reduce using rule 33 (addop -> PLUS .)
    MINUS           reduce using rule 33 (addop -> PLUS .)
    EXCLAMATION     reduce using rule 33 (addop -> PLUS .)
    TILDE           reduce using rule 33 (addop -> PLUS .)
    IDENT           reduce using rule 33 (addop -> PLUS .)
    LPAREN          reduce using rule 33 (addop -> PLUS .)
    NUMBER          reduce using rule 33 (addop -> PLUS .)
    TRUE            reduce using rule 33 (addop -> PLUS .)
    FALSE           reduce using rule 33 (addop -> PLUS .)


state 84

    (34) addop -> MINUS .

    PLUS            reduce using rule 34 (addop -> MINUS .)
    MINUS           reduce using rule 34 (addop -> MINUS .)
    EXCLAMATION     reduce using rule 34 (addop -> MINUS .)
    TILDE           reduce using rule 34 (addop -> MINUS .)
    IDENT           reduce using rule 34 (addop -> MINUS .)
    LPAREN          reduce using rule 34 (addop -> MINUS .)
    NUMBER          reduce using rule 34 (addop -> MINUS .)
    TRUE            reduce using rule 34 (addop -> MINUS .)
    FALSE           reduce using rule 34 (addop -> MINUS .)


state 85

    (40) compop -> GEQ .

    PLUS            reduce using rule 40 (compop -> GEQ .)
    MINUS           reduce using rule 40 (compop -> GEQ .)
    EXCLAMATION     reduce using rule 40 (compop -> GEQ .)
    TILDE           reduce using rule 40 (compop -> GEQ .)
    IDENT           reduce using rule 40 (compop -> GEQ .)
    LPAREN          reduce using rule 40 (compop -> GEQ .)
    NUMBER          reduce using rule 40 (compop -> GEQ .)
    TRUE            reduce using rule 40 (compop -> GEQ .)
    FALSE           reduce using rule 40 (compop -> GEQ .)


state 86

    (39) compop -> GT .

    PLUS            reduce using rule 39 (compop -> GT .)
    MINUS           reduce using rule 39 (compop -> GT .)
    EXCLAMATION     reduce using rule 39 (compop -> GT .)
    TILDE           reduce using rule 39 (compop -> GT .)
    IDENT           reduce using rule 39 (compop -> GT .)
    LPAREN          reduce using rule 39 (compop -> GT .)
    NUMBER          reduce using rule 39 (compop -> GT .)
    TRUE            reduce using rule 39 (compop -> GT .)
    FALSE           reduce using rule 39 (compop -> GT .)


state 87

    (38) compop -> LEQ .

    PLUS            reduce using rule 38 (compop -> LEQ .)
    MINUS           reduce using rule 38 (compop -> LEQ .)
    EXCLAMATION     reduce using rule 38 (compop -> LEQ .)
    TILDE           reduce using rule 38 (compop -> LEQ .)
    IDENT           reduce using rule 38 (compop -> LEQ .)
    LPAREN          reduce using rule 38 (compop -> LEQ .)
    NUMBER          reduce using rule 38 (compop -> LEQ .)
    TRUE            reduce using rule 38 (compop -> LEQ .)
    FALSE           reduce using rule 38 (compop -> LEQ .)


state 88

    (36) relationalExpression -> relationalExpression compop . additiveExpression
    (31) additiveExpression -> . unaryExpression
    (32) additiveExpression -> . additiveExpression addop multiplicativeExpression
    (21) unaryExpression -> . unop unaryExpression
    (22) unaryExpression -> . postfixExpression
    (23) unop -> . PLUS
    (24) unop -> . MINUS
    (25) unop -> . EXCLAMATION
    (26) unop -> . TILDE
    (16) postfixExpression -> . constant
    (17) postfixExpression -> . IDENT
    (18) postfixExpression -> . LPAREN expression RPAREN
    (19) postfixExpression -> . postfixExpression LBRACKET expression RBRACKET
    (20) postfixExpression -> . IDENT LPAREN expressionlist RPAREN
    (13) constant -> . NUMBER
    (14) constant -> . TRUE
    (15) constant -> . FALSE

    PLUS            shift and go to state 55
    MINUS           shift and go to state 53
    EXCLAMATION     shift and go to state 60
    TILDE           shift and go to state 56
    IDENT           shift and go to state 35
    LPAREN          shift and go to state 38
    NUMBER          shift and go to state 30
    TRUE            shift and go to state 31
    FALSE           shift and go to state 42

    additiveExpression             shift and go to state 108
    unaryExpression                shift and go to state 59
    unop                           shift and go to state 52
    postfixExpression              shift and go to state 63
    constant                       shift and go to state 29

state 89

    (37) compop -> LT .

    PLUS            reduce using rule 37 (compop -> LT .)
    MINUS           reduce using rule 37 (compop -> LT .)
    EXCLAMATION     reduce using rule 37 (compop -> LT .)
    TILDE           reduce using rule 37 (compop -> LT .)
    IDENT           reduce using rule 37 (compop -> LT .)
    LPAREN          reduce using rule 37 (compop -> LT .)
    NUMBER          reduce using rule 37 (compop -> LT .)
    TRUE            reduce using rule 37 (compop -> LT .)
    FALSE           reduce using rule 37 (compop -> LT .)


state 90

    (46) andExpression -> andExpression AND . equalityExpression
    (41) equalityExpression -> . relationalExpression
    (42) equalityExpression -> . equalityExpression eqop relationalExpression
    (35) relationalExpression -> . additiveExpression
    (36) relationalExpression -> . relationalExpression compop additiveExpression
    (31) additiveExpression -> . unaryExpression
    (32) additiveExpression -> . additiveExpression addop multiplicativeExpression
    (21) unaryExpression -> . unop unaryExpression
    (22) unaryExpression -> . postfixExpression
    (23) unop -> . PLUS
    (24) unop -> . MINUS
    (25) unop -> . EXCLAMATION
    (26) unop -> . TILDE
    (16) postfixExpression -> . constant
    (17) postfixExpression -> . IDENT
    (18) postfixExpression -> . LPAREN expression RPAREN
    (19) postfixExpression -> . postfixExpression LBRACKET expression RBRACKET
    (20) postfixExpression -> . IDENT LPAREN expressionlist RPAREN
    (13) constant -> . NUMBER
    (14) constant -> . TRUE
    (15) constant -> . FALSE

    PLUS            shift and go to state 55
    MINUS           shift and go to state 53
    EXCLAMATION     shift and go to state 60
    TILDE           shift and go to state 56
    IDENT           shift and go to state 35
    LPAREN          shift and go to state 38
    NUMBER          shift and go to state 30
    TRUE            shift and go to state 31
    FALSE           shift and go to state 42

    equalityExpression             shift and go to state 109
    additiveExpression             shift and go to state 57
    unaryExpression                shift and go to state 59
    relationalExpression           shift and go to state 61
    unop                           shift and go to state 52
    postfixExpression              shift and go to state 63
    constant                       shift and go to state 29

state 91

    (18) postfixExpression -> LPAREN expression RPAREN .

    EQ              reduce using rule 18 (postfixExpression -> LPAREN expression RPAREN .)
    LBRACKET        reduce using rule 18 (postfixExpression -> LPAREN expression RPAREN .)
    PLUS            reduce using rule 18 (postfixExpression -> LPAREN expression RPAREN .)
    MINUS           reduce using rule 18 (postfixExpression -> LPAREN expression RPAREN .)
    LT              reduce using rule 18 (postfixExpression -> LPAREN expression RPAREN .)
    LEQ             reduce using rule 18 (postfixExpression -> LPAREN expression RPAREN .)
    GT              reduce using rule 18 (postfixExpression -> LPAREN expression RPAREN .)
    GEQ             reduce using rule 18 (postfixExpression -> LPAREN expression RPAREN .)
    EQEQ            reduce using rule 18 (postfixExpression -> LPAREN expression RPAREN .)
    NEQ             reduce using rule 18 (postfixExpression -> LPAREN expression RPAREN .)
    AND             reduce using rule 18 (postfixExpression -> LPAREN expression RPAREN .)
    QUESTION        reduce using rule 18 (postfixExpression -> LPAREN expression RPAREN .)
    OR              reduce using rule 18 (postfixExpression -> LPAREN expression RPAREN .)
    SEMICOLON       reduce using rule 18 (postfixExpression -> LPAREN expression RPAREN .)
    RPAREN          reduce using rule 18 (postfixExpression -> LPAREN expression RPAREN .)
    COMMA           reduce using rule 18 (postfixExpression -> LPAREN expression RPAREN .)
    RBRACKET        reduce using rule 18 (postfixExpression -> LPAREN expression RPAREN .)
    COLON           reduce using rule 18 (postfixExpression -> LPAREN expression RPAREN .)
    TIMES           reduce using rule 18 (postfixExpression -> LPAREN expression RPAREN .)
    DIV             reduce using rule 18 (postfixExpression -> LPAREN expression RPAREN .)


state 92

    (65) selectionStatement -> IF LPAREN expression . RPAREN statement ELSE statement
    (66) selectionStatement -> IF LPAREN expression . RPAREN statement

    RPAREN          shift and go to state 110


state 93

    (58) assignmentStatement -> postfixExpression EQ error .

    SEMICOLON       reduce using rule 58 (assignmentStatement -> postfixExpression EQ error .)
    RPAREN          reduce using rule 58 (assignmentStatement -> postfixExpression EQ error .)


state 94

    (57) assignmentStatement -> postfixExpression EQ expression .

    SEMICOLON       reduce using rule 57 (assignmentStatement -> postfixExpression EQ expression .)
    RPAREN          reduce using rule 57 (assignmentStatement -> postfixExpression EQ expression .)


state 95

    (19) postfixExpression -> postfixExpression LBRACKET expression . RBRACKET

    RBRACKET        shift and go to state 111


state 96

    (59) assignmentStatement -> error EQ expression .

    SEMICOLON       reduce using rule 59 (assignmentStatement -> error EQ expression .)
    RPAREN          reduce using rule 59 (assignmentStatement -> error EQ expression .)


state 97

    (5) sequentialspec -> SEQUENTIAL LPAREN arglist RPAREN RETURNS LPAREN identlist . RPAREN LOCALS LPAREN arglist RPAREN block

    RPAREN          shift and go to state 112


state 98

    (10) identlist -> IDENT .
    (11) identlist -> IDENT . COMMA identlist

    RPAREN          reduce using rule 10 (identlist -> IDENT .)
    COMMA           shift and go to state 113


state 99

    (2) joinspec -> JOIN LPAREN arglist SEPARE arglist RPAREN RETURNS LPAREN identlist . RPAREN LOCALS LPAREN arglist RPAREN block
    (4) joinspec -> JOIN LPAREN arglist SEPARE arglist RPAREN RETURNS LPAREN identlist . RPAREN LOCALS LPAREN arglist RPAREN error

    RPAREN          shift and go to state 114


state 100

    (20) postfixExpression -> IDENT LPAREN expressionlist RPAREN .

    EQ              reduce using rule 20 (postfixExpression -> IDENT LPAREN expressionlist RPAREN .)
    LBRACKET        reduce using rule 20 (postfixExpression -> IDENT LPAREN expressionlist RPAREN .)
    PLUS            reduce using rule 20 (postfixExpression -> IDENT LPAREN expressionlist RPAREN .)
    MINUS           reduce using rule 20 (postfixExpression -> IDENT LPAREN expressionlist RPAREN .)
    LT              reduce using rule 20 (postfixExpression -> IDENT LPAREN expressionlist RPAREN .)
    LEQ             reduce using rule 20 (postfixExpression -> IDENT LPAREN expressionlist RPAREN .)
    GT              reduce using rule 20 (postfixExpression -> IDENT LPAREN expressionlist RPAREN .)
    GEQ             reduce using rule 20 (postfixExpression -> IDENT LPAREN expressionlist RPAREN .)
    EQEQ            reduce using rule 20 (postfixExpression -> IDENT LPAREN expressionlist RPAREN .)
    NEQ             reduce using rule 20 (postfixExpression -> IDENT LPAREN expressionlist RPAREN .)
    AND             reduce using rule 20 (postfixExpression -> IDENT LPAREN expressionlist RPAREN .)
    QUESTION        reduce using rule 20 (postfixExpression -> IDENT LPAREN expressionlist RPAREN .)
    OR              reduce using rule 20 (postfixExpression -> IDENT LPAREN expressionlist RPAREN .)
    SEMICOLON       reduce using rule 20 (postfixExpression -> IDENT LPAREN expressionlist RPAREN .)
    RPAREN          reduce using rule 20 (postfixExpression -> IDENT LPAREN expressionlist RPAREN .)
    COMMA           reduce using rule 20 (postfixExpression -> IDENT LPAREN expressionlist RPAREN .)
    RBRACKET        reduce using rule 20 (postfixExpression -> IDENT LPAREN expressionlist RPAREN .)
    COLON           reduce using rule 20 (postfixExpression -> IDENT LPAREN expressionlist RPAREN .)
    TIMES           reduce using rule 20 (postfixExpression -> IDENT LPAREN expressionlist RPAREN .)
    DIV             reduce using rule 20 (postfixExpression -> IDENT LPAREN expressionlist RPAREN .)


state 101

    (53) expressionlist -> expressionlist COMMA . expression
    (51) expression -> . conditionalExpression
    (49) conditionalExpression -> . orExpression
    (50) conditionalExpression -> . orExpression QUESTION expression COLON expression
    (47) orExpression -> . andExpression
    (48) orExpression -> . orExpression OR andExpression
    (45) andExpression -> . equalityExpression
    (46) andExpression -> . andExpression AND equalityExpression
    (41) equalityExpression -> . relationalExpression
    (42) equalityExpression -> . equalityExpression eqop relationalExpression
    (35) relationalExpression -> . additiveExpression
    (36) relationalExpression -> . relationalExpression compop additiveExpression
    (31) additiveExpression -> . unaryExpression
    (32) additiveExpression -> . additiveExpression addop multiplicativeExpression
    (21) unaryExpression -> . unop unaryExpression
    (22) unaryExpression -> . postfixExpression
    (23) unop -> . PLUS
    (24) unop -> . MINUS
    (25) unop -> . EXCLAMATION
    (26) unop -> . TILDE
    (16) postfixExpression -> . constant
    (17) postfixExpression -> . IDENT
    (18) postfixExpression -> . LPAREN expression RPAREN
    (19) postfixExpression -> . postfixExpression LBRACKET expression RBRACKET
    (20) postfixExpression -> . IDENT LPAREN expressionlist RPAREN
    (13) constant -> . NUMBER
    (14) constant -> . TRUE
    (15) constant -> . FALSE

    PLUS            shift and go to state 55
    MINUS           shift and go to state 53
    EXCLAMATION     shift and go to state 60
    TILDE           shift and go to state 56
    IDENT           shift and go to state 35
    LPAREN          shift and go to state 38
    NUMBER          shift and go to state 30
    TRUE            shift and go to state 31
    FALSE           shift and go to state 42

    equalityExpression             shift and go to state 51
    additiveExpression             shift and go to state 57
    conditionalExpression          shift and go to state 58
    unaryExpression                shift and go to state 59
    orExpression                   shift and go to state 54
    relationalExpression           shift and go to state 61
    unop                           shift and go to state 52
    andExpression                  shift and go to state 62
    postfixExpression              shift and go to state 63
    constant                       shift and go to state 29
    expression                     shift and go to state 115

state 102

    (67) iterationStatement -> FOR LPAREN assignmentStatement SEMICOLON . expression SEMICOLON assignmentStatement RPAREN statement
    (51) expression -> . conditionalExpression
    (49) conditionalExpression -> . orExpression
    (50) conditionalExpression -> . orExpression QUESTION expression COLON expression
    (47) orExpression -> . andExpression
    (48) orExpression -> . orExpression OR andExpression
    (45) andExpression -> . equalityExpression
    (46) andExpression -> . andExpression AND equalityExpression
    (41) equalityExpression -> . relationalExpression
    (42) equalityExpression -> . equalityExpression eqop relationalExpression
    (35) relationalExpression -> . additiveExpression
    (36) relationalExpression -> . relationalExpression compop additiveExpression
    (31) additiveExpression -> . unaryExpression
    (32) additiveExpression -> . additiveExpression addop multiplicativeExpression
    (21) unaryExpression -> . unop unaryExpression
    (22) unaryExpression -> . postfixExpression
    (23) unop -> . PLUS
    (24) unop -> . MINUS
    (25) unop -> . EXCLAMATION
    (26) unop -> . TILDE
    (16) postfixExpression -> . constant
    (17) postfixExpression -> . IDENT
    (18) postfixExpression -> . LPAREN expression RPAREN
    (19) postfixExpression -> . postfixExpression LBRACKET expression RBRACKET
    (20) postfixExpression -> . IDENT LPAREN expressionlist RPAREN
    (13) constant -> . NUMBER
    (14) constant -> . TRUE
    (15) constant -> . FALSE

    PLUS            shift and go to state 55
    MINUS           shift and go to state 53
    EXCLAMATION     shift and go to state 60
    TILDE           shift and go to state 56
    IDENT           shift and go to state 35
    LPAREN          shift and go to state 38
    NUMBER          shift and go to state 30
    TRUE            shift and go to state 31
    FALSE           shift and go to state 42

    equalityExpression             shift and go to state 51
    additiveExpression             shift and go to state 57
    conditionalExpression          shift and go to state 58
    unaryExpression                shift and go to state 59
    orExpression                   shift and go to state 54
    relationalExpression           shift and go to state 61
    unop                           shift and go to state 52
    andExpression                  shift and go to state 62
    postfixExpression              shift and go to state 63
    constant                       shift and go to state 29
    expression                     shift and go to state 116

state 103

    (42) equalityExpression -> equalityExpression eqop relationalExpression .
    (36) relationalExpression -> relationalExpression . compop additiveExpression
    (37) compop -> . LT
    (38) compop -> . LEQ
    (39) compop -> . GT
    (40) compop -> . GEQ

    EQEQ            reduce using rule 42 (equalityExpression -> equalityExpression eqop relationalExpression .)
    NEQ             reduce using rule 42 (equalityExpression -> equalityExpression eqop relationalExpression .)
    AND             reduce using rule 42 (equalityExpression -> equalityExpression eqop relationalExpression .)
    QUESTION        reduce using rule 42 (equalityExpression -> equalityExpression eqop relationalExpression .)
    OR              reduce using rule 42 (equalityExpression -> equalityExpression eqop relationalExpression .)
    SEMICOLON       reduce using rule 42 (equalityExpression -> equalityExpression eqop relationalExpression .)
    RPAREN          reduce using rule 42 (equalityExpression -> equalityExpression eqop relationalExpression .)
    COMMA           reduce using rule 42 (equalityExpression -> equalityExpression eqop relationalExpression .)
    RBRACKET        reduce using rule 42 (equalityExpression -> equalityExpression eqop relationalExpression .)
    COLON           reduce using rule 42 (equalityExpression -> equalityExpression eqop relationalExpression .)
    LT              shift and go to state 89
    LEQ             shift and go to state 87
    GT              shift and go to state 86
    GEQ             shift and go to state 85

    compop                         shift and go to state 88

state 104

    (50) conditionalExpression -> orExpression QUESTION expression . COLON expression

    COLON           shift and go to state 117


state 105

    (48) orExpression -> orExpression OR andExpression .
    (46) andExpression -> andExpression . AND equalityExpression

    QUESTION        reduce using rule 48 (orExpression -> orExpression OR andExpression .)
    OR              reduce using rule 48 (orExpression -> orExpression OR andExpression .)
    RPAREN          reduce using rule 48 (orExpression -> orExpression OR andExpression .)
    COMMA           reduce using rule 48 (orExpression -> orExpression OR andExpression .)
    COLON           reduce using rule 48 (orExpression -> orExpression OR andExpression .)
    SEMICOLON       reduce using rule 48 (orExpression -> orExpression OR andExpression .)
    RBRACKET        reduce using rule 48 (orExpression -> orExpression OR andExpression .)
    AND             shift and go to state 90


state 106

    (32) additiveExpression -> additiveExpression addop multiplicativeExpression .
    (28) multiplicativeExpression -> multiplicativeExpression . multop unaryExpression
    (29) multop -> . TIMES
    (30) multop -> . DIV

    PLUS            reduce using rule 32 (additiveExpression -> additiveExpression addop multiplicativeExpression .)
    MINUS           reduce using rule 32 (additiveExpression -> additiveExpression addop multiplicativeExpression .)
    LT              reduce using rule 32 (additiveExpression -> additiveExpression addop multiplicativeExpression .)
    LEQ             reduce using rule 32 (additiveExpression -> additiveExpression addop multiplicativeExpression .)
    GT              reduce using rule 32 (additiveExpression -> additiveExpression addop multiplicativeExpression .)
    GEQ             reduce using rule 32 (additiveExpression -> additiveExpression addop multiplicativeExpression .)
    EQEQ            reduce using rule 32 (additiveExpression -> additiveExpression addop multiplicativeExpression .)
    NEQ             reduce using rule 32 (additiveExpression -> additiveExpression addop multiplicativeExpression .)
    AND             reduce using rule 32 (additiveExpression -> additiveExpression addop multiplicativeExpression .)
    QUESTION        reduce using rule 32 (additiveExpression -> additiveExpression addop multiplicativeExpression .)
    OR              reduce using rule 32 (additiveExpression -> additiveExpression addop multiplicativeExpression .)
    RPAREN          reduce using rule 32 (additiveExpression -> additiveExpression addop multiplicativeExpression .)
    COMMA           reduce using rule 32 (additiveExpression -> additiveExpression addop multiplicativeExpression .)
    SEMICOLON       reduce using rule 32 (additiveExpression -> additiveExpression addop multiplicativeExpression .)
    RBRACKET        reduce using rule 32 (additiveExpression -> additiveExpression addop multiplicativeExpression .)
    COLON           reduce using rule 32 (additiveExpression -> additiveExpression addop multiplicativeExpression .)
    TIMES           shift and go to state 118
    DIV             shift and go to state 120

    multop                         shift and go to state 119

state 107

    (27) multiplicativeExpression -> unaryExpression .

    TIMES           reduce using rule 27 (multiplicativeExpression -> unaryExpression .)
    DIV             reduce using rule 27 (multiplicativeExpression -> unaryExpression .)
    PLUS            reduce using rule 27 (multiplicativeExpression -> unaryExpression .)
    MINUS           reduce using rule 27 (multiplicativeExpression -> unaryExpression .)
    LT              reduce using rule 27 (multiplicativeExpression -> unaryExpression .)
    LEQ             reduce using rule 27 (multiplicativeExpression -> unaryExpression .)
    GT              reduce using rule 27 (multiplicativeExpression -> unaryExpression .)
    GEQ             reduce using rule 27 (multiplicativeExpression -> unaryExpression .)
    EQEQ            reduce using rule 27 (multiplicativeExpression -> unaryExpression .)
    NEQ             reduce using rule 27 (multiplicativeExpression -> unaryExpression .)
    AND             reduce using rule 27 (multiplicativeExpression -> unaryExpression .)
    QUESTION        reduce using rule 27 (multiplicativeExpression -> unaryExpression .)
    OR              reduce using rule 27 (multiplicativeExpression -> unaryExpression .)
    RPAREN          reduce using rule 27 (multiplicativeExpression -> unaryExpression .)
    COMMA           reduce using rule 27 (multiplicativeExpression -> unaryExpression .)
    SEMICOLON       reduce using rule 27 (multiplicativeExpression -> unaryExpression .)
    RBRACKET        reduce using rule 27 (multiplicativeExpression -> unaryExpression .)
    COLON           reduce using rule 27 (multiplicativeExpression -> unaryExpression .)


state 108

    (36) relationalExpression -> relationalExpression compop additiveExpression .
    (32) additiveExpression -> additiveExpression . addop multiplicativeExpression
    (33) addop -> . PLUS
    (34) addop -> . MINUS

    LT              reduce using rule 36 (relationalExpression -> relationalExpression compop additiveExpression .)
    LEQ             reduce using rule 36 (relationalExpression -> relationalExpression compop additiveExpression .)
    GT              reduce using rule 36 (relationalExpression -> relationalExpression compop additiveExpression .)
    GEQ             reduce using rule 36 (relationalExpression -> relationalExpression compop additiveExpression .)
    EQEQ            reduce using rule 36 (relationalExpression -> relationalExpression compop additiveExpression .)
    NEQ             reduce using rule 36 (relationalExpression -> relationalExpression compop additiveExpression .)
    AND             reduce using rule 36 (relationalExpression -> relationalExpression compop additiveExpression .)
    QUESTION        reduce using rule 36 (relationalExpression -> relationalExpression compop additiveExpression .)
    OR              reduce using rule 36 (relationalExpression -> relationalExpression compop additiveExpression .)
    COLON           reduce using rule 36 (relationalExpression -> relationalExpression compop additiveExpression .)
    SEMICOLON       reduce using rule 36 (relationalExpression -> relationalExpression compop additiveExpression .)
    RPAREN          reduce using rule 36 (relationalExpression -> relationalExpression compop additiveExpression .)
    COMMA           reduce using rule 36 (relationalExpression -> relationalExpression compop additiveExpression .)
    RBRACKET        reduce using rule 36 (relationalExpression -> relationalExpression compop additiveExpression .)
    PLUS            shift and go to state 83
    MINUS           shift and go to state 84

    addop                          shift and go to state 82

state 109

    (46) andExpression -> andExpression AND equalityExpression .
    (42) equalityExpression -> equalityExpression . eqop relationalExpression
    (43) eqop -> . EQEQ
    (44) eqop -> . NEQ

    AND             reduce using rule 46 (andExpression -> andExpression AND equalityExpression .)
    QUESTION        reduce using rule 46 (andExpression -> andExpression AND equalityExpression .)
    OR              reduce using rule 46 (andExpression -> andExpression AND equalityExpression .)
    RBRACKET        reduce using rule 46 (andExpression -> andExpression AND equalityExpression .)
    RPAREN          reduce using rule 46 (andExpression -> andExpression AND equalityExpression .)
    COMMA           reduce using rule 46 (andExpression -> andExpression AND equalityExpression .)
    SEMICOLON       reduce using rule 46 (andExpression -> andExpression AND equalityExpression .)
    COLON           reduce using rule 46 (andExpression -> andExpression AND equalityExpression .)
    EQEQ            shift and go to state 76
    NEQ             shift and go to state 78

    eqop                           shift and go to state 77

state 110

    (65) selectionStatement -> IF LPAREN expression RPAREN . statement ELSE statement
    (66) selectionStatement -> IF LPAREN expression RPAREN . statement
    (60) statement -> . assignmentStatement SEMICOLON
    (61) statement -> . iterationStatement
    (62) statement -> . selectionStatement
    (63) statement -> . block
    (64) statement -> . error SEMICOLON
    (57) assignmentStatement -> . postfixExpression EQ expression
    (58) assignmentStatement -> . postfixExpression EQ error
    (59) assignmentStatement -> . error EQ expression
    (67) iterationStatement -> . FOR LPAREN assignmentStatement SEMICOLON expression SEMICOLON assignmentStatement RPAREN statement
    (65) selectionStatement -> . IF LPAREN expression RPAREN statement ELSE statement
    (66) selectionStatement -> . IF LPAREN expression RPAREN statement
    (68) block -> . LBRACE statementlist RBRACE
    (69) block -> . LBRACE error RBRACE
    (16) postfixExpression -> . constant
    (17) postfixExpression -> . IDENT
    (18) postfixExpression -> . LPAREN expression RPAREN
    (19) postfixExpression -> . postfixExpression LBRACKET expression RBRACKET
    (20) postfixExpression -> . IDENT LPAREN expressionlist RPAREN
    (13) constant -> . NUMBER
    (14) constant -> . TRUE
    (15) constant -> . FALSE

    error           shift and go to state 43
    FOR             shift and go to state 37
    IF              shift and go to state 40
    LBRACE          shift and go to state 20
    IDENT           shift and go to state 35
    LPAREN          shift and go to state 38
    NUMBER          shift and go to state 30
    TRUE            shift and go to state 31
    FALSE           shift and go to state 42

    postfixExpression              shift and go to state 41
    constant                       shift and go to state 29
    block                          shift and go to state 44
    statement                      shift and go to state 121
    assignmentStatement            shift and go to state 34
    iterationStatement             shift and go to state 39
    selectionStatement             shift and go to state 32

state 111

    (19) postfixExpression -> postfixExpression LBRACKET expression RBRACKET .

    EQ              reduce using rule 19 (postfixExpression -> postfixExpression LBRACKET expression RBRACKET .)
    LBRACKET        reduce using rule 19 (postfixExpression -> postfixExpression LBRACKET expression RBRACKET .)
    PLUS            reduce using rule 19 (postfixExpression -> postfixExpression LBRACKET expression RBRACKET .)
    MINUS           reduce using rule 19 (postfixExpression -> postfixExpression LBRACKET expression RBRACKET .)
    LT              reduce using rule 19 (postfixExpression -> postfixExpression LBRACKET expression RBRACKET .)
    LEQ             reduce using rule 19 (postfixExpression -> postfixExpression LBRACKET expression RBRACKET .)
    GT              reduce using rule 19 (postfixExpression -> postfixExpression LBRACKET expression RBRACKET .)
    GEQ             reduce using rule 19 (postfixExpression -> postfixExpression LBRACKET expression RBRACKET .)
    EQEQ            reduce using rule 19 (postfixExpression -> postfixExpression LBRACKET expression RBRACKET .)
    NEQ             reduce using rule 19 (postfixExpression -> postfixExpression LBRACKET expression RBRACKET .)
    AND             reduce using rule 19 (postfixExpression -> postfixExpression LBRACKET expression RBRACKET .)
    QUESTION        reduce using rule 19 (postfixExpression -> postfixExpression LBRACKET expression RBRACKET .)
    OR              reduce using rule 19 (postfixExpression -> postfixExpression LBRACKET expression RBRACKET .)
    SEMICOLON       reduce using rule 19 (postfixExpression -> postfixExpression LBRACKET expression RBRACKET .)
    RPAREN          reduce using rule 19 (postfixExpression -> postfixExpression LBRACKET expression RBRACKET .)
    COMMA           reduce using rule 19 (postfixExpression -> postfixExpression LBRACKET expression RBRACKET .)
    RBRACKET        reduce using rule 19 (postfixExpression -> postfixExpression LBRACKET expression RBRACKET .)
    COLON           reduce using rule 19 (postfixExpression -> postfixExpression LBRACKET expression RBRACKET .)
    TIMES           reduce using rule 19 (postfixExpression -> postfixExpression LBRACKET expression RBRACKET .)
    DIV             reduce using rule 19 (postfixExpression -> postfixExpression LBRACKET expression RBRACKET .)


state 112

    (5) sequentialspec -> SEQUENTIAL LPAREN arglist RPAREN RETURNS LPAREN identlist RPAREN . LOCALS LPAREN arglist RPAREN block

    LOCALS          shift and go to state 122


state 113

    (11) identlist -> IDENT COMMA . identlist
    (10) identlist -> . IDENT
    (11) identlist -> . IDENT COMMA identlist
    (12) identlist -> .

    IDENT           shift and go to state 98
    RPAREN          reduce using rule 12 (identlist -> .)

    identlist                      shift and go to state 123

state 114

    (2) joinspec -> JOIN LPAREN arglist SEPARE arglist RPAREN RETURNS LPAREN identlist RPAREN . LOCALS LPAREN arglist RPAREN block
    (4) joinspec -> JOIN LPAREN arglist SEPARE arglist RPAREN RETURNS LPAREN identlist RPAREN . LOCALS LPAREN arglist RPAREN error

    LOCALS          shift and go to state 124


state 115

    (53) expressionlist -> expressionlist COMMA expression .

    RPAREN          reduce using rule 53 (expressionlist -> expressionlist COMMA expression .)
    COMMA           reduce using rule 53 (expressionlist -> expressionlist COMMA expression .)


state 116

    (67) iterationStatement -> FOR LPAREN assignmentStatement SEMICOLON expression . SEMICOLON assignmentStatement RPAREN statement

    SEMICOLON       shift and go to state 125


state 117

    (50) conditionalExpression -> orExpression QUESTION expression COLON . expression
    (51) expression -> . conditionalExpression
    (49) conditionalExpression -> . orExpression
    (50) conditionalExpression -> . orExpression QUESTION expression COLON expression
    (47) orExpression -> . andExpression
    (48) orExpression -> . orExpression OR andExpression
    (45) andExpression -> . equalityExpression
    (46) andExpression -> . andExpression AND equalityExpression
    (41) equalityExpression -> . relationalExpression
    (42) equalityExpression -> . equalityExpression eqop relationalExpression
    (35) relationalExpression -> . additiveExpression
    (36) relationalExpression -> . relationalExpression compop additiveExpression
    (31) additiveExpression -> . unaryExpression
    (32) additiveExpression -> . additiveExpression addop multiplicativeExpression
    (21) unaryExpression -> . unop unaryExpression
    (22) unaryExpression -> . postfixExpression
    (23) unop -> . PLUS
    (24) unop -> . MINUS
    (25) unop -> . EXCLAMATION
    (26) unop -> . TILDE
    (16) postfixExpression -> . constant
    (17) postfixExpression -> . IDENT
    (18) postfixExpression -> . LPAREN expression RPAREN
    (19) postfixExpression -> . postfixExpression LBRACKET expression RBRACKET
    (20) postfixExpression -> . IDENT LPAREN expressionlist RPAREN
    (13) constant -> . NUMBER
    (14) constant -> . TRUE
    (15) constant -> . FALSE

    PLUS            shift and go to state 55
    MINUS           shift and go to state 53
    EXCLAMATION     shift and go to state 60
    TILDE           shift and go to state 56
    IDENT           shift and go to state 35
    LPAREN          shift and go to state 38
    NUMBER          shift and go to state 30
    TRUE            shift and go to state 31
    FALSE           shift and go to state 42

    equalityExpression             shift and go to state 51
    additiveExpression             shift and go to state 57
    conditionalExpression          shift and go to state 58
    unaryExpression                shift and go to state 59
    orExpression                   shift and go to state 54
    relationalExpression           shift and go to state 61
    unop                           shift and go to state 52
    andExpression                  shift and go to state 62
    postfixExpression              shift and go to state 63
    constant                       shift and go to state 29
    expression                     shift and go to state 126

state 118

    (29) multop -> TIMES .

    PLUS            reduce using rule 29 (multop -> TIMES .)
    MINUS           reduce using rule 29 (multop -> TIMES .)
    EXCLAMATION     reduce using rule 29 (multop -> TIMES .)
    TILDE           reduce using rule 29 (multop -> TIMES .)
    IDENT           reduce using rule 29 (multop -> TIMES .)
    LPAREN          reduce using rule 29 (multop -> TIMES .)
    NUMBER          reduce using rule 29 (multop -> TIMES .)
    TRUE            reduce using rule 29 (multop -> TIMES .)
    FALSE           reduce using rule 29 (multop -> TIMES .)


state 119

    (28) multiplicativeExpression -> multiplicativeExpression multop . unaryExpression
    (21) unaryExpression -> . unop unaryExpression
    (22) unaryExpression -> . postfixExpression
    (23) unop -> . PLUS
    (24) unop -> . MINUS
    (25) unop -> . EXCLAMATION
    (26) unop -> . TILDE
    (16) postfixExpression -> . constant
    (17) postfixExpression -> . IDENT
    (18) postfixExpression -> . LPAREN expression RPAREN
    (19) postfixExpression -> . postfixExpression LBRACKET expression RBRACKET
    (20) postfixExpression -> . IDENT LPAREN expressionlist RPAREN
    (13) constant -> . NUMBER
    (14) constant -> . TRUE
    (15) constant -> . FALSE

    PLUS            shift and go to state 55
    MINUS           shift and go to state 53
    EXCLAMATION     shift and go to state 60
    TILDE           shift and go to state 56
    IDENT           shift and go to state 35
    LPAREN          shift and go to state 38
    NUMBER          shift and go to state 30
    TRUE            shift and go to state 31
    FALSE           shift and go to state 42

    unop                           shift and go to state 52
    postfixExpression              shift and go to state 63
    constant                       shift and go to state 29
    unaryExpression                shift and go to state 127

state 120

    (30) multop -> DIV .

    PLUS            reduce using rule 30 (multop -> DIV .)
    MINUS           reduce using rule 30 (multop -> DIV .)
    EXCLAMATION     reduce using rule 30 (multop -> DIV .)
    TILDE           reduce using rule 30 (multop -> DIV .)
    IDENT           reduce using rule 30 (multop -> DIV .)
    LPAREN          reduce using rule 30 (multop -> DIV .)
    NUMBER          reduce using rule 30 (multop -> DIV .)
    TRUE            reduce using rule 30 (multop -> DIV .)
    FALSE           reduce using rule 30 (multop -> DIV .)


state 121

    (65) selectionStatement -> IF LPAREN expression RPAREN statement . ELSE statement
    (66) selectionStatement -> IF LPAREN expression RPAREN statement .

  ! shift/reduce conflict for ELSE resolved as shift
    ELSE            shift and go to state 128
    RBRACE          reduce using rule 66 (selectionStatement -> IF LPAREN expression RPAREN statement .)
    error           reduce using rule 66 (selectionStatement -> IF LPAREN expression RPAREN statement .)
    FOR             reduce using rule 66 (selectionStatement -> IF LPAREN expression RPAREN statement .)
    IF              reduce using rule 66 (selectionStatement -> IF LPAREN expression RPAREN statement .)
    LBRACE          reduce using rule 66 (selectionStatement -> IF LPAREN expression RPAREN statement .)
    IDENT           reduce using rule 66 (selectionStatement -> IF LPAREN expression RPAREN statement .)
    LPAREN          reduce using rule 66 (selectionStatement -> IF LPAREN expression RPAREN statement .)
    NUMBER          reduce using rule 66 (selectionStatement -> IF LPAREN expression RPAREN statement .)
    TRUE            reduce using rule 66 (selectionStatement -> IF LPAREN expression RPAREN statement .)
    FALSE           reduce using rule 66 (selectionStatement -> IF LPAREN expression RPAREN statement .)

  ! ELSE            [ reduce using rule 66 (selectionStatement -> IF LPAREN expression RPAREN statement .) ]


state 122

    (5) sequentialspec -> SEQUENTIAL LPAREN arglist RPAREN RETURNS LPAREN identlist RPAREN LOCALS . LPAREN arglist RPAREN block

    LPAREN          shift and go to state 129


state 123

    (11) identlist -> IDENT COMMA identlist .

    RPAREN          reduce using rule 11 (identlist -> IDENT COMMA identlist .)


state 124

    (2) joinspec -> JOIN LPAREN arglist SEPARE arglist RPAREN RETURNS LPAREN identlist RPAREN LOCALS . LPAREN arglist RPAREN block
    (4) joinspec -> JOIN LPAREN arglist SEPARE arglist RPAREN RETURNS LPAREN identlist RPAREN LOCALS . LPAREN arglist RPAREN error

    LPAREN          shift and go to state 130


state 125

    (67) iterationStatement -> FOR LPAREN assignmentStatement SEMICOLON expression SEMICOLON . assignmentStatement RPAREN statement
    (57) assignmentStatement -> . postfixExpression EQ expression
    (58) assignmentStatement -> . postfixExpression EQ error
    (59) assignmentStatement -> . error EQ expression
    (16) postfixExpression -> . constant
    (17) postfixExpression -> . IDENT
    (18) postfixExpression -> . LPAREN expression RPAREN
    (19) postfixExpression -> . postfixExpression LBRACKET expression RBRACKET
    (20) postfixExpression -> . IDENT LPAREN expressionlist RPAREN
    (13) constant -> . NUMBER
    (14) constant -> . TRUE
    (15) constant -> . FALSE

    error           shift and go to state 74
    IDENT           shift and go to state 35
    LPAREN          shift and go to state 38
    NUMBER          shift and go to state 30
    TRUE            shift and go to state 31
    FALSE           shift and go to state 42

    postfixExpression              shift and go to state 41
    constant                       shift and go to state 29
    assignmentStatement            shift and go to state 131

state 126

    (50) conditionalExpression -> orExpression QUESTION expression COLON expression .

    COLON           reduce using rule 50 (conditionalExpression -> orExpression QUESTION expression COLON expression .)
    RPAREN          reduce using rule 50 (conditionalExpression -> orExpression QUESTION expression COLON expression .)
    COMMA           reduce using rule 50 (conditionalExpression -> orExpression QUESTION expression COLON expression .)
    SEMICOLON       reduce using rule 50 (conditionalExpression -> orExpression QUESTION expression COLON expression .)
    RBRACKET        reduce using rule 50 (conditionalExpression -> orExpression QUESTION expression COLON expression .)


state 127

    (28) multiplicativeExpression -> multiplicativeExpression multop unaryExpression .

    TIMES           reduce using rule 28 (multiplicativeExpression -> multiplicativeExpression multop unaryExpression .)
    DIV             reduce using rule 28 (multiplicativeExpression -> multiplicativeExpression multop unaryExpression .)
    PLUS            reduce using rule 28 (multiplicativeExpression -> multiplicativeExpression multop unaryExpression .)
    MINUS           reduce using rule 28 (multiplicativeExpression -> multiplicativeExpression multop unaryExpression .)
    LT              reduce using rule 28 (multiplicativeExpression -> multiplicativeExpression multop unaryExpression .)
    LEQ             reduce using rule 28 (multiplicativeExpression -> multiplicativeExpression multop unaryExpression .)
    GT              reduce using rule 28 (multiplicativeExpression -> multiplicativeExpression multop unaryExpression .)
    GEQ             reduce using rule 28 (multiplicativeExpression -> multiplicativeExpression multop unaryExpression .)
    EQEQ            reduce using rule 28 (multiplicativeExpression -> multiplicativeExpression multop unaryExpression .)
    NEQ             reduce using rule 28 (multiplicativeExpression -> multiplicativeExpression multop unaryExpression .)
    AND             reduce using rule 28 (multiplicativeExpression -> multiplicativeExpression multop unaryExpression .)
    QUESTION        reduce using rule 28 (multiplicativeExpression -> multiplicativeExpression multop unaryExpression .)
    OR              reduce using rule 28 (multiplicativeExpression -> multiplicativeExpression multop unaryExpression .)
    RPAREN          reduce using rule 28 (multiplicativeExpression -> multiplicativeExpression multop unaryExpression .)
    COMMA           reduce using rule 28 (multiplicativeExpression -> multiplicativeExpression multop unaryExpression .)
    SEMICOLON       reduce using rule 28 (multiplicativeExpression -> multiplicativeExpression multop unaryExpression .)
    RBRACKET        reduce using rule 28 (multiplicativeExpression -> multiplicativeExpression multop unaryExpression .)
    COLON           reduce using rule 28 (multiplicativeExpression -> multiplicativeExpression multop unaryExpression .)


state 128

    (65) selectionStatement -> IF LPAREN expression RPAREN statement ELSE . statement
    (60) statement -> . assignmentStatement SEMICOLON
    (61) statement -> . iterationStatement
    (62) statement -> . selectionStatement
    (63) statement -> . block
    (64) statement -> . error SEMICOLON
    (57) assignmentStatement -> . postfixExpression EQ expression
    (58) assignmentStatement -> . postfixExpression EQ error
    (59) assignmentStatement -> . error EQ expression
    (67) iterationStatement -> . FOR LPAREN assignmentStatement SEMICOLON expression SEMICOLON assignmentStatement RPAREN statement
    (65) selectionStatement -> . IF LPAREN expression RPAREN statement ELSE statement
    (66) selectionStatement -> . IF LPAREN expression RPAREN statement
    (68) block -> . LBRACE statementlist RBRACE
    (69) block -> . LBRACE error RBRACE
    (16) postfixExpression -> . constant
    (17) postfixExpression -> . IDENT
    (18) postfixExpression -> . LPAREN expression RPAREN
    (19) postfixExpression -> . postfixExpression LBRACKET expression RBRACKET
    (20) postfixExpression -> . IDENT LPAREN expressionlist RPAREN
    (13) constant -> . NUMBER
    (14) constant -> . TRUE
    (15) constant -> . FALSE

    error           shift and go to state 43
    FOR             shift and go to state 37
    IF              shift and go to state 40
    LBRACE          shift and go to state 20
    IDENT           shift and go to state 35
    LPAREN          shift and go to state 38
    NUMBER          shift and go to state 30
    TRUE            shift and go to state 31
    FALSE           shift and go to state 42

    postfixExpression              shift and go to state 41
    constant                       shift and go to state 29
    block                          shift and go to state 44
    statement                      shift and go to state 132
    assignmentStatement            shift and go to state 34
    iterationStatement             shift and go to state 39
    selectionStatement             shift and go to state 32

state 129

    (5) sequentialspec -> SEQUENTIAL LPAREN arglist RPAREN RETURNS LPAREN identlist RPAREN LOCALS LPAREN . arglist RPAREN block
    (6) arglist -> . arglist COMMA arg
    (7) arglist -> . arg
    (8) arglist -> .
    (9) arg -> . type IDENT
    (70) type -> . INT
    (71) type -> . FLOAT
    (72) type -> . BOOL
    (73) type -> . type TIMES

    RPAREN          reduce using rule 8 (arglist -> .)
    COMMA           reduce using rule 8 (arglist -> .)
    INT             shift and go to state 8
    FLOAT           shift and go to state 11
    BOOL            shift and go to state 13

    arglist                        shift and go to state 133
    type                           shift and go to state 9
    arg                            shift and go to state 10

state 130

    (2) joinspec -> JOIN LPAREN arglist SEPARE arglist RPAREN RETURNS LPAREN identlist RPAREN LOCALS LPAREN . arglist RPAREN block
    (4) joinspec -> JOIN LPAREN arglist SEPARE arglist RPAREN RETURNS LPAREN identlist RPAREN LOCALS LPAREN . arglist RPAREN error
    (6) arglist -> . arglist COMMA arg
    (7) arglist -> . arg
    (8) arglist -> .
    (9) arg -> . type IDENT
    (70) type -> . INT
    (71) type -> . FLOAT
    (72) type -> . BOOL
    (73) type -> . type TIMES

    RPAREN          reduce using rule 8 (arglist -> .)
    COMMA           reduce using rule 8 (arglist -> .)
    INT             shift and go to state 8
    FLOAT           shift and go to state 11
    BOOL            shift and go to state 13

    arglist                        shift and go to state 134
    type                           shift and go to state 9
    arg                            shift and go to state 10

state 131

    (67) iterationStatement -> FOR LPAREN assignmentStatement SEMICOLON expression SEMICOLON assignmentStatement . RPAREN statement

    RPAREN          shift and go to state 135


state 132

    (65) selectionStatement -> IF LPAREN expression RPAREN statement ELSE statement .

    ELSE            reduce using rule 65 (selectionStatement -> IF LPAREN expression RPAREN statement ELSE statement .)
    RBRACE          reduce using rule 65 (selectionStatement -> IF LPAREN expression RPAREN statement ELSE statement .)
    error           reduce using rule 65 (selectionStatement -> IF LPAREN expression RPAREN statement ELSE statement .)
    FOR             reduce using rule 65 (selectionStatement -> IF LPAREN expression RPAREN statement ELSE statement .)
    IF              reduce using rule 65 (selectionStatement -> IF LPAREN expression RPAREN statement ELSE statement .)
    LBRACE          reduce using rule 65 (selectionStatement -> IF LPAREN expression RPAREN statement ELSE statement .)
    IDENT           reduce using rule 65 (selectionStatement -> IF LPAREN expression RPAREN statement ELSE statement .)
    LPAREN          reduce using rule 65 (selectionStatement -> IF LPAREN expression RPAREN statement ELSE statement .)
    NUMBER          reduce using rule 65 (selectionStatement -> IF LPAREN expression RPAREN statement ELSE statement .)
    TRUE            reduce using rule 65 (selectionStatement -> IF LPAREN expression RPAREN statement ELSE statement .)
    FALSE           reduce using rule 65 (selectionStatement -> IF LPAREN expression RPAREN statement ELSE statement .)


state 133

    (5) sequentialspec -> SEQUENTIAL LPAREN arglist RPAREN RETURNS LPAREN identlist RPAREN LOCALS LPAREN arglist . RPAREN block
    (6) arglist -> arglist . COMMA arg

    RPAREN          shift and go to state 136
    COMMA           shift and go to state 18


state 134

    (2) joinspec -> JOIN LPAREN arglist SEPARE arglist RPAREN RETURNS LPAREN identlist RPAREN LOCALS LPAREN arglist . RPAREN block
    (4) joinspec -> JOIN LPAREN arglist SEPARE arglist RPAREN RETURNS LPAREN identlist RPAREN LOCALS LPAREN arglist . RPAREN error
    (6) arglist -> arglist . COMMA arg

    RPAREN          shift and go to state 137
    COMMA           shift and go to state 18


state 135

    (67) iterationStatement -> FOR LPAREN assignmentStatement SEMICOLON expression SEMICOLON assignmentStatement RPAREN . statement
    (60) statement -> . assignmentStatement SEMICOLON
    (61) statement -> . iterationStatement
    (62) statement -> . selectionStatement
    (63) statement -> . block
    (64) statement -> . error SEMICOLON
    (57) assignmentStatement -> . postfixExpression EQ expression
    (58) assignmentStatement -> . postfixExpression EQ error
    (59) assignmentStatement -> . error EQ expression
    (67) iterationStatement -> . FOR LPAREN assignmentStatement SEMICOLON expression SEMICOLON assignmentStatement RPAREN statement
    (65) selectionStatement -> . IF LPAREN expression RPAREN statement ELSE statement
    (66) selectionStatement -> . IF LPAREN expression RPAREN statement
    (68) block -> . LBRACE statementlist RBRACE
    (69) block -> . LBRACE error RBRACE
    (16) postfixExpression -> . constant
    (17) postfixExpression -> . IDENT
    (18) postfixExpression -> . LPAREN expression RPAREN
    (19) postfixExpression -> . postfixExpression LBRACKET expression RBRACKET
    (20) postfixExpression -> . IDENT LPAREN expressionlist RPAREN
    (13) constant -> . NUMBER
    (14) constant -> . TRUE
    (15) constant -> . FALSE

    error           shift and go to state 43
    FOR             shift and go to state 37
    IF              shift and go to state 40
    LBRACE          shift and go to state 20
    IDENT           shift and go to state 35
    LPAREN          shift and go to state 38
    NUMBER          shift and go to state 30
    TRUE            shift and go to state 31
    FALSE           shift and go to state 42

    postfixExpression              shift and go to state 41
    constant                       shift and go to state 29
    block                          shift and go to state 44
    statement                      shift and go to state 138
    assignmentStatement            shift and go to state 34
    iterationStatement             shift and go to state 39
    selectionStatement             shift and go to state 32

state 136

    (5) sequentialspec -> SEQUENTIAL LPAREN arglist RPAREN RETURNS LPAREN identlist RPAREN LOCALS LPAREN arglist RPAREN . block
    (68) block -> . LBRACE statementlist RBRACE
    (69) block -> . LBRACE error RBRACE

    LBRACE          shift and go to state 20

    block                          shift and go to state 139

state 137

    (2) joinspec -> JOIN LPAREN arglist SEPARE arglist RPAREN RETURNS LPAREN identlist RPAREN LOCALS LPAREN arglist RPAREN . block
    (4) joinspec -> JOIN LPAREN arglist SEPARE arglist RPAREN RETURNS LPAREN identlist RPAREN LOCALS LPAREN arglist RPAREN . error
    (68) block -> . LBRACE statementlist RBRACE
    (69) block -> . LBRACE error RBRACE

    error           shift and go to state 141
    LBRACE          shift and go to state 20

    block                          shift and go to state 140

state 138

    (67) iterationStatement -> FOR LPAREN assignmentStatement SEMICOLON expression SEMICOLON assignmentStatement RPAREN statement .

    ELSE            reduce using rule 67 (iterationStatement -> FOR LPAREN assignmentStatement SEMICOLON expression SEMICOLON assignmentStatement RPAREN statement .)
    RBRACE          reduce using rule 67 (iterationStatement -> FOR LPAREN assignmentStatement SEMICOLON expression SEMICOLON assignmentStatement RPAREN statement .)
    error           reduce using rule 67 (iterationStatement -> FOR LPAREN assignmentStatement SEMICOLON expression SEMICOLON assignmentStatement RPAREN statement .)
    FOR             reduce using rule 67 (iterationStatement -> FOR LPAREN assignmentStatement SEMICOLON expression SEMICOLON assignmentStatement RPAREN statement .)
    IF              reduce using rule 67 (iterationStatement -> FOR LPAREN assignmentStatement SEMICOLON expression SEMICOLON assignmentStatement RPAREN statement .)
    LBRACE          reduce using rule 67 (iterationStatement -> FOR LPAREN assignmentStatement SEMICOLON expression SEMICOLON assignmentStatement RPAREN statement .)
    IDENT           reduce using rule 67 (iterationStatement -> FOR LPAREN assignmentStatement SEMICOLON expression SEMICOLON assignmentStatement RPAREN statement .)
    LPAREN          reduce using rule 67 (iterationStatement -> FOR LPAREN assignmentStatement SEMICOLON expression SEMICOLON assignmentStatement RPAREN statement .)
    NUMBER          reduce using rule 67 (iterationStatement -> FOR LPAREN assignmentStatement SEMICOLON expression SEMICOLON assignmentStatement RPAREN statement .)
    TRUE            reduce using rule 67 (iterationStatement -> FOR LPAREN assignmentStatement SEMICOLON expression SEMICOLON assignmentStatement RPAREN statement .)
    FALSE           reduce using rule 67 (iterationStatement -> FOR LPAREN assignmentStatement SEMICOLON expression SEMICOLON assignmentStatement RPAREN statement .)


state 139

    (5) sequentialspec -> SEQUENTIAL LPAREN arglist RPAREN RETURNS LPAREN identlist RPAREN LOCALS LPAREN arglist RPAREN block .

    $end            reduce using rule 5 (sequentialspec -> SEQUENTIAL LPAREN arglist RPAREN RETURNS LPAREN identlist RPAREN LOCALS LPAREN arglist RPAREN block .)


state 140

    (2) joinspec -> JOIN LPAREN arglist SEPARE arglist RPAREN RETURNS LPAREN identlist RPAREN LOCALS LPAREN arglist RPAREN block .

    SEQUENTIAL      reduce using rule 2 (joinspec -> JOIN LPAREN arglist SEPARE arglist RPAREN RETURNS LPAREN identlist RPAREN LOCALS LPAREN arglist RPAREN block .)


state 141

    (4) joinspec -> JOIN LPAREN arglist SEPARE arglist RPAREN RETURNS LPAREN identlist RPAREN LOCALS LPAREN arglist RPAREN error .

    SEQUENTIAL      reduce using rule 4 (joinspec -> JOIN LPAREN arglist SEPARE arglist RPAREN RETURNS LPAREN identlist RPAREN LOCALS LPAREN arglist RPAREN error .)

WARNING: 
WARNING: Conflicts:
WARNING: 
WARNING: shift/reduce conflict for error in state 20 resolved as shift
WARNING: shift/reduce conflict for ELSE in state 121 resolved as shift
